
A Description of the CLOGO Language and System (ver. 0.4)

0. Abstract
-----------

This document is based on Bolt Beranek and Newman, Inc., Report no.1889 "Programming-Languages as a Conceptual Framework for Teaching Mathematics" (Feurzeig, Papert at al., 1969). The description is relevant for CLOGO version 44 available on PDP-10/its. https://github.com/PDP-10/its.

1.The LOGO Language
-------------------


1.1 Things, Operations, Commands, and Names


There are two kinds of LOGO things -- WORDS and SENTENCES.

WORDS
-----

Examples of LOGO WORDS:
"SUN"              (an English word)
"39"               (a numerical word)
"PFFS!T!220W*?"    (a nonsence word)
""                 (a special word called the EMPTY word)

SENTENCES
---------

A LOGO SENTENCE is a series of LOGO words, separated by spaces.(LOGO words do not contain spaces.)
Examples:
"GOOD MORNING"
"X + Y = 24.5"
"FLOOCH HUM BUZZ CHORB"

OPERATIONS
----------

LOGO has several elementary (i.e., built-in) OPERATIONS for manipulating LOGO things.A LOGO operation takes a fixed number of things (possibly none) as INPUTS and produces a new thing as an OUTPUT. Examples of" some built-in operations_FIRST, LAST, BUTFIRST, BUTLAST, WORD and SENTENCE-follow.


FIRST
-----

The operation FIRST takes one input, either word or sentence.Its output is the first letter (if the input is word), or the first word (if the input is a sentence).
Thus,
FIRST OF "CAT" is "C"
and
FIRST OF "DO RE MI" is "DO".

LAST, BUTFIRST, and BUTLAST
---------------------------

These operations are similar to FIRST, as the following examples show.

Name of operation              Input            Output
-----------------              -----            ------
LAST                           "CAT"            "T"
BUTFIRST                       "CAT"            "AT"
BUTLAST                        "CAT"            "CA"
LAST                           "DO RE MI"       "MI"
BUTFIRST                       "DO RE MI"       "RE MI"
BUTLAST                        "DO RE MI"       "DO RE"


WORD and SENTENCE

These operations take two inputs.Their output is the concatenation of their inputs.The inputs of WORD must be LOGO words, not sentences.The output of WORD is a LOGO word.Thus, WORD OF "DO" AND "RE" is "DORE".The inputs of SENTENCE can be LOGO words or LOGO sentences.The
output is a LOGO sentence.Thus,


Name of Operation              Inputs           Output
-----------------              ------           ------
WORD                           "TIC" "TAC"      "TICTAC"
SENTENCE                       "TIC" "TAC"      "TIC TAC"
SENTENCE                       "PUT ME" "HERE"  "PUT ME HERE"
WORD                           "PUT ME" "HERE"  (Error Message)


The entire set of elementary, i.e., built-in, operations is
described in Section 1.7.

CHAINING

Operations can be chained together to form composite operations. Examples:
Chained Operation                              Output
-----------------                              ------
FIRST OF BUTFIRST OF "CAT"                      "A"
LAST OF FIRST OF "DO RE MI"                     "0"
WORD OF BUTLAST OF "CAT" AND LAST OF "X9"       "CA9"
SENTENCE OF WORD OF "A" AND "B" AND "C"         "AB C"
WORD OF "Z" AND SUM OF "1" AND "2"              "Z3"

COMMANDS
--------

LOGO has several built-in COMMANDS. Commands have inputs but, unlike operations, do not make a new LOGO thing, i.e.,they have no output.They are used for their external effects or for their side effects.

PRINT is a built-in LOGO command which has one input.Though it has no output, it has the tangible effect of causing its input to be printed out by the terminal. Thus,

Input                           Printout
-----                           --------
PRINT"CAT"			CAT
PRINT LAST OF "BOX"		X

Other built-in LOGO commands include MAKE which is used to give names to LOGO things, and TO which is used to define new LOGO operations and commands.These are describedinlater paragraphs of this section.

LITERALS
--------

In the examples above, some words and sentences are enclosed in quotation marks.This means that we reciting them literally, to refer to themselves rather than to other LOGO things.But we also can use LOGO things as names for other LOGO things.

NAMES
-----

LOGO things can have NAMES. Any LOGO thing (except the empty word) can be used as a name for any other LOGO thing.Assume that we have assigned "JANE" as the name of the thing"GIRL". We now can use"JANE" in two ways -either as thing (itself) or as a name(for the thing"GIRL").
To indicate to LOGO that we want to use something as name(in order to refer to the thing that it names), we have LOGO operation -THING, whose input is a LOGO thingandwhose output is the LOGO thing named by the input.Thus,
with the example above

Command				Printout
-------				--------
PRINT "JANE"			JANE
PRINT THING OF "JANE"		GIRL


A shorthand way of writing THING OF "ANYTHING" is :ANYTHING. Thus, the effect of the command PRINT :JANE is to cause the terminal to print GIRL.

NAMING
------

The LOGO command MAKE is used to construct a LOGO THING and give it a NAME. The following example shows how a user could use it to assign "JANE" as the name of "GIRL".

MAKE
----
   NAME: "JANE"
         ------
   THING: "GIRL"
          -----

The user's typing is underscored to distinguish it from LOGO's responses.

More typically, one names a more complex construction, as follows:

MAKE
----
   NAME: "JIM"
   	 -----
   THING: LAST OF BUTLAST OF :JANE
   	  ------------------------
	  
In this instance, with :JANE assigned as above to "GIRL", :JIM would name the THING "R" (since BUTLAST of :JANE is "GIR" and LAST of "GIR" is "R").


Constructing a New Operation

Suppose we want to define an operation which has one input and whose output is the second letter of its input (if the input is word) or the second word (if the input is sentence). We will call this new operation SECOND. (We can choose any word not already being used by LOGO as procedure name.) The procedure for performing SECOND is described to LOGO as follows.

	TO SECOND :ANYTHING
	1 OUTPUT FIRST OF BUTFIRST OF :ANYTHING
	END

TO is a command that signals the start of a procedure definition. The name of the procedure we are defining is SECOND. Its input is :ANYTHING, which names the LOGO thing we will operate upon. It has a single instruction line (in general there are several), labeled 1. The instruction is: OUTPUT the thing expressed by the chained operation FIRST OF BUTFIRST OF the word (or sentence) named by :ANYTHING. END demarcates the end of the procedure definition.

SECOND is now the procedure name for a procedure which defines a new operation. To perform this new, user-defined (as distinct from elementary or built-in) operation, we can give LOGO the command
       PRINT SECOND OF "MAN".
This tells LOGO to perform the operation SECOND on the input"MAN", i.e., that :ANYTHING is now"MAN". LOGO will perform the instructions in the procedure. It will thus output "A" to the PRINT command which will cause the terminal to print A.


1.2 Instructions


The basic unit of a LOGO INSTRUCTION is a LOGO EXPRESSION. An expression has two parts: (1) a procedure name or the name of an elementary (built-in) command or operation, followed by (2) a list of the associated inputs. Some examples of expressions are:

    (a)WORD OF "CAT" AND "DOG"
    WORD is a built-in LOGO operation that requires two inputs,
    in this case "CAT" and "DOG". The output of this expression
    is the word "CATDOG".
    
    (b)SECOND OF "APPLE PIE SOUFFLE"
    SECOND is a procedure defined by the user which requires one
    input, in this case, "APPLE PIE SOUFFLE". Assuming that the
    procedure is defined as in the previous section, the output
    of the expression would be "PIE".
    
    (c)TIMETIME is a built-in operation that requires no inputs.The
    output of this expression is the current time, for example,
    "10:34 AM".
    
The inputs in expressions may be LOGO NAMES as well as LITERALS.

    (d)FIRST OF :CHILDREN
    FIRST is a built-in operation that requires one input.The
    input here is not "CHILDREN" but rather the thing that
    "CHILDREN" names.Thus, if "CHILDREN" is the name for the
    LOGO sentence "BOYS AND GIRLS", the output of the expression
    is "BOYS".


The inputs in expressions may themselves be expressions.

    (e)FIRST OF BUTFIRST OF "ABCD"
    Here the input of the operation FIRST is the output of the
    expression BUTFIRST OF "ABCD", that is "BCD".So the output
    of the whole expression is the same as the output of FIRST
    OF "BCD", that is "B".
    
Commands are expressions.For example,

    (f)PRINT OF "ABC"This expression has no output but it causes ABC to be
    printed by the terminal.
    
    (g)PRINT OF FIRST OF "ABC"
    If this expression, PRINT has, as its input, the output of
    FIRST OF "ABC", that is "A".The effect is to cause A to
    be printed by the terminal.
    
On the other hand, the form

   (h)FIRST OF PRINT OF "ABC"
   is not a legal expression because FIRST requires an input
   but the expression PRINT OF "ABC" has no output.
   
In writing expressions, the words OF and AND are optional.The expressions PRINT WORD "CAT" "DOG", PRINT OF WORD OF "CAT" AND"DOG", and PRINT WORD OF "CAT" AND "DOG" all have the same
meaning.



1.3 Procedures


Several LOGO instructions can be put together to form a PROCEDURE. This is accomplished using the instruction TO.(The user's typing is underscored to distinguish it from the computer's.)

	?TO GREET :NAME
	>10 PRINT SENTENCE OF "HELLO " AND :NAME
	>20 PRINT "I HOPE YOU'RE WELL."
	>END
	GREET DEFINED
	
	GREET "DICK"
	HELLO, DICK
	I HOPE YOU'RE WELL.
	
The instruction in first line of the example, TO GREET :NAME does several things.The word TO tells the computer that we are about to define a procedure.The next word GREET is the name of the procedure. Following this is the list of input names for the procedure, in this case only one. (If we had wanted a two-input procedure, like WORD, the first line might have been TO GREET :WHO AND :WHERE. Any number of inputs is permitted including none.) The names appearing in the input list are used in subsequent instructions to refer to the associated inputs.

After the TO instruction (also called the title line of the procedure), the computer types > at the beginning of each line to indicate that it is ready for the type-in of the next line of the procedure being defined. At this point any line typed in preceded by a number (between 1 and 999999 inclusive), as lines 10 and 20 in GREET, will be made part of the procedure definition. These instructions will subsequently be performed in the numerical sequence thus indicated. The instructions are not performed immediately as they are written  - they are merely stored as part of the definition. They can be performed later when the procedure definition has been completed.

Finally, the command END (which has no inputs) completes the definition of the procedure. The computer types GREET DEFINED. Now the computer begins lines with an question mark "?" indicating that it is ready to perform an instruction (possibly a procedure).
GREET may now be used as a LOGO command.The expression GREET "DICK" (or GREET OF "DICK") causes the computer to pair the input, "DICK" with the name in the title line of GREET, :NAME,and then to carry out the instructions in the body of the procedure GREET in the numerical order of their line numbers.

There are two ways to change the numerical order of execution of the instructions in a procedure. The first is by the command
      GO TO LINE expression
                 ----------
where the value of expression must be a line number. (Although the name of this command is sentence, GO TO LINE, it is a single entity of the same kind as commands whose names are single words.) The effect of this command is shown in the following example.

      ?TO SHOWGOTOLINE :X
      >10 GO TO LINE :X
      >20 PRINT "1"
      >30 PRINT "2"
      >40 PRINT "3"
      >50 PRINT "4"
      >END
      SHOWGOTOLINE DEFINED

      ?SHOWGOTOLINE "50"
      4
      ?SHOWGOTOLINE "30"
      2
      3
      4

      ?SHOWGOTOLINE "25"
      THERE IS NO LINE 25                   (LOGO types out these
      I WAS AT LINE 10 IN SHOWGOTOLINE      diagnostic comments.)

      ?SHOWGOTOLINE "10"
           (interrupt key pressed here after some time has gone
	   by with no printout)
      I WAS AT LINE 10 IN SHOWGOTOLINE
      
In the above example SHOWGOTOLINE "l0" caused the computer to do line 10 over and over again until it was interrupted from the terminal. A more standard example of the use of GO TO LINE is as follows.

      ?TO TWOTIMES
      >10 MAKE
           NAME:"X"
	   THING:"1"
      >20 PRINT :X
      >30 MAKE
           NAME:"X"
	   THING:SUM OF :X AND :X
      >40 GO TO LINE 20
      >END
      TWOTIMES DEFINED

      TWO TIMES
      1
      2
      4
      8
      16
      32
      64
      (interrupted from terminal)
      I WAS AT LINE 20 IN TWOTIMES
      
The other way of altering the numerical order of execution of the instructions in a procedure is with the trio of commands TEST,IF TRUE, and IF FALSE.TEST takes one input, which must be an operation whose output must be either "TRUE" or "FALSE". (TEST can also take as input the literal words "TRUE" and "FALSE".) The effect of performing the command TEST expression is to mark a "truth flag" either true or false, depending on whether the output of expression is "TRUE" or "FALSE", respectively.
      
IF TRUE and IF FALSE are somewhat anomalous commands in that their input can be any instruction, even a command. That instruction is executed if the truth flag matches the second word of the IF--- command.

      ?TEST "TRUE"
      > IF TRUE PRINT "OF COURSE"
      OF COURSE
      ?IF FALSE PRINT "STRANGE"
      (No printout occurs since the truth flag is
      marked TRUE)
      
      ?TO SHOWTEST :X
      >10 TEST :X
      >20 IF TRUE PRINT "AXLE"
      >30 IF FALSE PRINT "CAKE"
      >40 IF TRUE PRINT "SUBWAY"
      >END
      SHOWTEST DEFINED
      ?SHOWTEST LAST OF "BLUE TRUE"
      AXLE
      SUBWAY
      ?SHOWTEST FIRST OF "FALSE LOVE"
      CAKE
      
The IF commands can be used with GO TO LINE instructions to provide conditional branching within a procedure.More broadly,they can be used to alter the sequence of execution of procedures within a program comprising many procedures (as in 30 IF TRUETARUM40 IF FALSE TARAY where the condition of the truth flag determines whether the computer does the procedure TARUM or the procedure TARAY).

TEST is made more useful by a collection of built-in operations which output either "TRUE" or "FALSE". Operations which can have only these two values are called predicates. Section 1.7 includes a list of the built-in predicates.


1.4 Defined Operations


It is possible to define new LOGO operations (i.e., procedures which have an output) by means of the command OUTPUT.

      ?TO DOUBLE :X
      >10 OUTPUT WORD OF :X AND :X
      >END
      DOUBLE DEFINED
      ?PRINT DOUBLE OF "CAT"
      CATCAT
      ?PRINT DOUBLE OF DOUBLE OF "GO"
      GOGOGOGO
      
An apparently equivalent procedure that doesn't have an output is

      ?TO DUB :X
      >10 PRINT WORD OF :X AND :X
      >END
      DUB DEFINED
      ?DUB "CAT"
      CATCAT
      
Notice that it wasn't necessary to say PRINT DUB OF "CAT" since DUB contains a PRINT command.(The appearance and disappearance of the OF is purely for euphony.The computer ignores it.) Whatfif an external PRINT'is used?

      ?PRINT DUB OF "CAT"
      CATCAT
      DUB CAN'T BE USED AS AN INPUT.IT DOESN'T HAVE AN OUTPUT.

LOGO complains.The problem is that the external PRINT didn't get any input because DUB didn't output anything -- DUB is command, not an operation.The word "CATCAT" got printed anyway because that happens before the computer gets to the end of DUB and discovers that there is no output to transmit to the external PRINT command.

The same thing happens, giving an obviously wrong answer, whe none writes
      ?DUB DUB "GO"GOGO
      GOGO
      
      DUB CAN'T BE USED AS AN INPUT.IT DOESN'T HAVE AN OUTPUT.
      
Once procedures like DOUBLE or DUB are defined, they are virtually indistinguishable in their use from the built-in operations and commands.Thus, in the same way as with the built-in ones, these too can be used to define other procedures.
      ?TO TRIPLE :X
      >10 OUTPUT WORD OF :X AND DOUBLE OF :X
      >END
      TRIPLE DEFINED
      ?PRINT TRIPLE OF "AB
      "ABABAB
      ?PRINT TRIPLE OF DOUBLE OF "R"
      RRPRRRR


1.5 Recursion

pIn fact, since a defined procedure can be used just like a built-in procedure, it can even be used in its own definition. Sometimes this gets nowhere -

      ?TO TYPEALOT
      >10 TYPEALOT
      >END
      TYPEALOT DEFINED
      >TYPEALOT
         (after a long wait the interrupt key is hit)
      I WAS AT LINE 10 IN TYPEALOT
      
It was silly to expect the computer to have been able to performthis procedure (to type a lot?) with the instructions we gave. If it didn't know what TYPEALOT meant before we defined it, it certainly wouldn't now. But it clearly was doing something when we said TYPEALOT since the terminal didn't type an ? or an error message.

When the computer receives the instruction TYPEALOT, it sees that the instruction names a defined procedure. In order to perform it, it has to look up the instructions contained in the procedure definition. The title line shows that no inputs are needed.Then the next line tells the computerto perform theprocedure TYPEALOT. To do this, the computer must look up the procedure TYPEALOT and then perform the instructions contained there.When it does this, it once more finds that it must lookup the procedure TYPEALOT, all over again. And again and again. And so this goes on forever. (Actually, the LOGO system will assume that there is an error after it has looked up this procefdure about 500 times, and will then cause the computer to stop.)

Of course, it would have been easy to design LOGO so that it would remember what procedure it was doing and not allow this situation to occur. It turns out, though, that we would have deprived ourselves of a very valuable mathematical tool had we done this.

The simplest use of the above effect (called recursion because of the recurrence of the same definition) is to note that if there had been a line preceding line 10 in the procedure TYPEALOT, this line would be done over and over again, every time the procedure is looked up. Let us add a new line, say line 5.
      ?TO TYPEALOT>
      5 PRINT "A LITTLE"
      > 10 TYPEALOT
      >END
      TYPEALOT DEFINED
      ?
      
      ?TYPEALOT
      A LITTLE
      A LITTLE
      A LITTLE
         .
	 .
	 .
	 
	     (the interrupt key is hit to stop it)
      I WAS AT LINE 5 IN TYPEALOT.


The following recursive procedure takes an input and has a stopping rule.

      ?TO TRIANGLE :ANYWORD
      > 10 TEST EMPTYP OF :ANYWORD
      > 20 IF TRUE STOP
      > 30 PRINT :ANYWORD
      > 40 TRIANGLE BUTFIRST OF :ANYWORD
      >END
      TRIANGLE DEFINED
      ?
      
EMPTYP is a built-in predicate operation that outputs "TRUE" if its input is the empty word and outputs "FALSE" otherwise. STOP is a built in command to stop this procedure, i.e., to skip the rest of the instructions in the procedure and go directly to the end.

      ?TRIANGLE ""(trying TRIANGLE with the empty word as the input)
      		  (nothing printed out but the program stopped)
      ?TRIANGLE "ABCDE"
      ABCDE
      BCDE
      CDE
      DE
      E
      ?

In the second example, the definition of TRIANGLE was looked up six times.The first five times the input was not the empty word, so the STOP command was skipped. The computer then typed the input and looked up TRIANGLE again, but this time with a smaller input (the butfirst of the previous one). Finally, the input was the empty word. For that input TRIANGLE skips lines 30 and 40 (so nothing is typed and the procedure is not looked up again) and it stops.
A well known example of this type of definition in arithmetic is the one for factorial:
      n! =1 if n=1, otherwise n!=n*(n-1)!
This can be transcribed directly to LOGO.

      ?TO FACTORIAL :N
      >10 TEST IS :N "1"
      >20 IF TRUE OUTPUT "1"
      >30 IF FALSE OUTPUT PRODUCT OF :N AND FACTORIAL OF
      	     DIFFERENCE OF :N AND "1"
      >END
      FACTORIAL DEFINED
      ?
      
IS is a built-in predicate that outputs "TRUE" if its two inputs are expressions for the same thing and"FALSE" otherwise. Line 30 is rather long but not too hard to read if one uses parentheses
PRODUCT OF ( :N ) AND (FACTORIAL OF [DIFFERENCE OF :N AND "1"]).
DIFFERENCE OF :N AND "1" is just fn-1.

Finally, it is not necessary to prefix the instruction in line 30 with the command IF FALSE, since the OUTPUT command incorporates the actions of the STOP command and, if line 20 is executed, the OUTPUT command there will skip to the end of the procedure.

1.6 Local and Global Names

In LOGO everything except the empty word is the name of something. Until they are otherwise assigned, almost all LOGO things name the empty word.

      ?PRINT :SOMETHING
          (The computer prints the empty word by skipping a line.)
      ?PRINT :AN_OTHER_THING

      ?PRINT :A

      ?PRINT ""
      THE EMPTY WORD CANNOT BE A NAME.
      ?

The few exceptions, which don't initially name the empty word, are built-in LOGO names for special things such as the console bell, the blank character, etc. These are listed in Part 3 (Need to be checked).

Names may have their things changed in two ways.The most direct way is by means of the instruction MAKE.

      ?MAKE
         NAME: "ALPHA"
	 THING: "BETTY"
      ?PRINT :ALPHA
      BETTY

The text following the words NAME: and THING: may be anything that has an output, that is a literal (like "ALPHA"),a name(like :JKS),or an operation with its inputs.
      ?MAKE
        NAME: :ALPHA
 	THING: "SAPLE"
      ?PRINT :BETTY
      SAPLE
      ?

The name here is :ALPHA, that is the LOGO thing "BETTY".

      ?MAKE
         NAME: SENTENCE OF "DOT" AND :ALPHA
	 THING: BUTFIRST OF :BETTY
      ?PRINT "DOT BETTY"
      APLE

Here the name of SENTENCE OF "DOT" AND :ALPHA which is "DOT BETTY" and the thing it names is BUTFIRST OF :BETTY, "APLE".

The instruction LIST ALL NAMES causes all names with non-empty things to be listed.

      ?LIST ALL NAMES
      :ALPHA IS "BETTY"
      :BETTY IS "SAPLE"
      "DOT BETTY" IS "APLE"  ;;need to be checked
      ?

Just as the OF and AND in most instructions are optional, the carriage returns after the command MAKE and before the label THING are optional. The instruction in the form

      ?MAKE(carriage return)
         NAME:"BB"(carriage return)
	 THING:"CABF"(carriage return)

can also be written with the two inputs on one line. Thus:

      ?MAKE "BB" "CABF"(carriage return)

The computer doesn't type out NAME: and THING: in this form so it is a little faster to type in.

The slow form is useful in emphasizing the relation between NAME and THING during the early stages of teaching, however.

The other method of changing names is by specifying inputs inprocedures.

      ?TO SHOW :X
      >10 PRINT "NOWI AM GOING TO PRINT :X"
      >20 PRINT :X
      >END
      >SHOW "CATS"
      NOWIAM GOING TO PRINT :X
      CATS
      ?

While the procedure SHOW is running, :X stands for "CATS". When it stops, however, the old THING OF "X" is restored. Thus,

      ?PRINT :X
              (the empty word)
      ?MAKE
         NAME:"X"
	 THING:"OLD THING"
      ?PRINT :X
      OLD THING
      ?SHOW "DOGS"
      NOW I AM GOING TO PRINT :X
      DOGS
      ?PRINT :X
      OLD THING
      ?

A name which is in force only during the running time of some procedure is called local tothat procedure. A name that isn't local to any procedure is called global. In the example above, :X ("OLD THING") was global, while :X ("DOGS") was local to SHOW. While a local :X is in force (i.e.,while the procedurefor which it is local is running), all references to :X as a name refer to the local name.
      ?TO WORRY :X
      >10 PRINT :X
      >30 PRINT THING OF "X"
      >40 MAKE
            NAME:"x"
	    THING: WORD OF "CAT" AND :X
      >50 PRINT :X
      >END
      WORRY DEFINED
      ?PRINT :X
      OLD THING
      ?WORRY "PIPE"
      PIPE
      PIPE
      CATPIPE
      ?PRINT :X
      OLD THING
      ?

One reason for this somewhat complicated situation is that it permits the user to forget about the choice of names inside of procedures that he has written. For example, suppose the user had written a procedure to output the product of two numbers and it had a title line TO PRODUCT :X AND :Y. Then, sometime later he wrote another program, called TO QUADRATIC :X, for computing (X+1)X+3X, which uses the procedure PRODUCT in its definition.
      ?TO QUADRATIC :X
      >10 MAKE
            NAME: "FIRST TERM"
	    THING: PRODUCT OF (SUM OF :X AND "1") AND :X
      >20 MAKE
            NAME: "SECOND TERM"
	    THING: PRODUCT OF "3" AND :X
      >30 OUTPUT SUM OF :FIRST_TERM AND :SECOND_TERM
      >END
      QUADRATIC DEFINED
      ?PRINT QUADRATIC OF "4"
      32
      ?

Notice that :X becomes "4" on entering QUADRATIC. In line 10 however PRODUCT OF "5" AND "4" is evaluated and so PRODUCT is run.But that causes :X to become "5" while PRODUCT is running. When PRODUCT is finished, however, we comeback to QUADRATIC, now at line 20 and see another reference to :X, meaning the :X of QUADRATIC ("4"). And, indeed, this is the way things work because the :X in PRODUCT is local tothat procedure and disappears when PRODUCT is finished, leaving the :X of QUADRATICin force.

In this case the problem could have been gotten around simply byusing different input names for all procedures, a possible, if awkward, maneuver. There is an important case where that won't work, though, and that is inrecursive procedures. There, since the procedure being called is the same procedure as the one being run, the input names are, of course,identical. Here is an example of a recursive procedure that doesn't work properly because some global names are treated as though they were local.

      ?TO REVERSE :X
      > 10 TEST EMPTYP OF :X
      > 20 IF TRUE OUTPUT :EMPTY
      > 30 MAKE
             NAME: "NEW BEGINNING"
	     THING: LAST OF :X
      >40 MAKE
             NAME:"NEW END"
	     THING: REVERSE OF BUTLAST OF :X
      >50 OUTPUT WORD OF :NEW_BEGINNING AND :NEW_END
      >END
      REVERSE DEFINED
      ?PRINT REVERSE OF "CAT"
      TTT
      ?

The problem here is at line 30 and at line 40. :NEW_BEGINNING isn't an input to REVERSE, so it isn't local. Therefore, its thing will change on subsequent calls of REVERSE. The computer does not save the things of global names in each round - it only does that for local names. (The same is true for :NEW_END though in this procedure that doesn't affect the result -- nothing that might change :NEW_END, such as a call to REVERSE, happens after line 40 where :NEW_END is set.) At line 40 another REVERSE is called. In executing this REVERSE procedure, :NEW_BEGINNING will change. REVERSE procedures can, of course, be written to avoid this problem. But this REVERSE procedure can easily be repaired by making :NEW_BEGINNING local to it. There is a command, LOCAL, to do this. LOCAL takes one input, the name that is to be made local to the procedure.

      ?TO REVERSE :X
      >5 LOCAL "NEW BEGINNING"
      > 10 TEST EMPTYP OF :X
             .   (same as before)
             .
             .
    
      >END
      REVERSE DEFINED
      ?PRINT REVERSE OF "CAT"
      TAC
      ?


1.7 List of Elementary Operations

1.FIRST (one input)
     Its output is the first word of a sentence or the first
     letter of a word.
     FIRST OF "AB12X!" is "A"
     FIRST OF "MOX SED PEAX" is "MOX"

2.LAST (one input)
     Its output is the last word of a sentence or the last letter
     of a word; analogous to FIRST.

3.BUTFIRST (one input)
     Its output is all but the first word of a sentence or all
     but the first letter of a word.
     BUTFIRST OF "AB12X!" is "B12X!"
     BUTFIRST OF "MOX SED PEAX" is "SED PEAX"
There is one tricky point here. BUTFIRST of a two-word sentenceis the last word of the sentence. It is a one-word sentence, however, not a word. This can be observed in the expression FIRST OF BUTFIRST OF "THE DOG" which has as its output the word"DOG" since that is the first word of the one-word sentence "DOG" that is the output of BUTFIRST OF "THE DOG". Continuing further,the output of FIRST OF FIRST OF BUTFIRST OF "THE DOG" is theword "D". In practice the output type (word or sentence) almost always works out as the user expects.

4.BUTLAST (one input)
     Analogous to BUTFIRST.
     (It is worth noting that the output of BUTFIRST or BUTLAST is the
     same type (word or sentence) as its input. On the other hand,
     the output of FIRST or LAST is always a word.)

5.WORD (two inputs)
     Both inputs must be words. The output of the expression is
     a new word made by concatenating the two inputs. 
     WORD OF "MO" AND "ZART" is "MOZART".

6.SENTENCE (two inputs)
     Analogous to WORD. Here the inputs may be either words or
     sentences and the value is a sentence.
     SENTENCE OF "MO" AND "ZART" is "MO ZART"
     SENTENCE OF "AB" AND "CD EF" is "AB CD EF"
     SENTENCE OF "" AND "APPLE" is "APPLE"
     In the last example the output is a one-word sentence again.

7.COUNT (one input)
     The output of the expression is the number of letters in
     the input if it is a word or the number of words if it is a
     sentence.
     COUNT OF "ABC" is "3"
     COUNT OF "THE CAT IN THE HAT" is "5"
     COUNT OF "" is "0"

8.SUM (two inputs)
     Both inputs must be numbers (i.e., words consisting only of
     digits preceded by an optional + or - sign). The output of the
     expression is the signed sum of the two inputs, prefixed by a -
     sign if the sum is negative.
     SUM OF "-5" AND "3" is "-2"
     SUM OF "5" AND "-2" is "3"

9.DIFFERENCE (two inputs)
     Analogous to SUM.The output is the result of subtracting
     the second input from the first.
     DIFFERENCE OF "3" AND "-5" is "8"

10.MAXIMUM (two inputs)
     Analogous to SUM. The output is the larger of the two inputs.
     MAXIMUM OF 2 AND 4 is 4.
     	      Integers do not need to be quoted in LOGO.

11.MINIMUM (two inputs)
     Analogous to SUM. The output is the smaller of the two inputs.

12.RANDOM (no inputs)
     The output is a digit between 0 and 9 generated in a pseudo
     -random manner. Larger pseudo-random numbers are generated
     by concatenation.Thus,
     WORD OF RANDOM AND RANDOM, yieldsa random number between
     00 and 99.

13.DATE (no inputs)
     The output is the current date, a word representing month, 
     day, year.For example,"10/31/1969".

14.TIME (no inputs)
     The output is the current time,a sentence like "1:32 AM".

15.CLOCK (no inputs)
     The output is a number giving the number of seconds
     elapsedsince an internal clock was reset.
               ?RESET CLOCK
	         .  (some work taking abouthalf an hour)
		 .
		 .
	       ?PRINT CLOCK
	       1836
	       ?PRINT CLOCK
	       1838

16.REQUEST (no inputs)
     When the computer evaluates the expressionREQUEST, it
     pauses to allow the user to type in something (often a requested 
     answer to a question) at the console. When the typing is 
     completed (as indicated when theuser types a carriage return),
     the output of the expression is thetyped-in text.The following
     procedure shows the use of REQUEST.

               ?TO COPYCAT
	       >10 PRINT "TELL ME SOMETHING."
	       >20 PRINT REQUEST
	       >30 COPYCAT
	       >END
	       COPYCAT DEFINED
	       ?

	       COPYCAT
	       TELL ME SOMETHING.
	       <WHO ARE YOU
	       WHO ARE YOU?
	       TELL ME SOMETHING.
	       <WHY SHOULD I
	       ?WHY SHOULD I
	       ?TELL ME SOMETHING.
	       <ARE YOU SOME KIND OF NUT
	       ARE YOU SOME KIND OF NUT
	       TELL ME SOMETHING.
	       <
	       .    .
	       .    .
	       .    .
     The less then sign (<) is typed by the REQUEST command to indicate to
     the user that the computer is waitingfor his typing.

17.ASK (one input)
     This is similar to REQUEST except that there is an input -
     the maximum number of seconds the computer should wait for type-in
     to be completed. If time runs out, the out put of the expression
     is the empty word.

18.THING (one input)
     The output of this expression is the thing named by the input.
     THING OF "X" is exactly the same as :X.The utility of THING
     lies in expressions like THING OF :X (the analogous ::X is illegal) 
     and THING OF WORD OF :X AND :Y. ???

The followingare all predicates; i.e., they output TRUEor FALSE.

19.IS (two inputs)
     This is the most general of the built-in predicates. Most 
     others could be built out of it.The output of the expression 
     is"TRUE" if the things expressed by the two inputsare identical,
     letter for letter; otherwiseits output is "FALSE".
     	       IS "CAT" "CAT" is "TRUE"
	       IS 03 is 3 is "FALSE"
	       IS LAST OF 03 FIRST OF 3 is "TRUE"

20.EMPTYP (one input)
     Its output is "TRUE" if the inputis the empty word.
     It is"FALSE" otherwise.
                EMPTYP OF :X has the same effect as 
     		IS :X ""    or
		IS :X :EMPTY ???

21.ZEROP (one input)
    The input must express a number, otherwise there is an error.
    If the input is equal to 0 (+0, -0, 00, etc.), the output of the
    expression is "TRUE". If the input is a non-zero number, the output 
    of the expression is "FALSE".

22.WORDP (one input)
     WORDP outputs "TRUE" if its input is a word (not a sentence).
     It outputs "FALSE" otherwise.

23.SENTENCEP (one input)
     Like WORDP, except it outputs "TRUE" if the input is a
     sentence. SENTENCEP and WORDP both output "TRUE" for the empty 
     word.For any other input their outputs are opposite.

24.NUMBERP (one input)
     NUMBERP outputs "TRUE" if its input is a number in standard
     form (that is, 123, +17, -000 give "TRUE", while A37, 7+8, ++3,
     7.5 give "FALSE"). NUMBERP outputs "TRUE" for precisely those
     things which are legal inputs for SUM, DIFFERENCE, ZEROP,
     GREATERP, MAXIMUM, and MINIMUM.

25.GREATERP (two inputs)
     The inputs must be numbers. GREATERP outputs "TRUE" if the
     first input is larger than the second. It outputs "FALSE" if
     the first is less than or equal to the second.


1.8 List of Elementary Commands


1.TO
     This command indicates the beginning of a procedure defini
     -tion. Immediately following the TO on the same instruction line
     is the name of the procedure being defined (this must be a word,
     not a sentence) and the names of its inputs, if it has any.

2.END (no inputs)
     This indicates the completion of a procedure definition.

3.OUTPUT (one input)
     This command causes a procedure to output the LOGO word or
     sentence specified in its input.It can only be used within the
     definition of a procedure.When the procedure is running and the
     OUTPUT command is encountered, its input becomes the output of 
     the procedure. The procedure then stops and LOGO proceeds with
     its program by running the instruction that called this 
     procedure.

4.STOP (no input)
     Like the command OUTPUT, STOP causes a procedure to stop 
     (but without causing it to output). Again, as with OUTPUT, the
     program then goes on with the instruction that invoked this
     procedure.

5.GO TO LINE (one input)
     Only used within the definition of a procedure.The input
     must be the number of a line in that procedure (or an operation
     whose output is such a number). When the procedure runs, execu-
     tion of the GO TO LINE command causes the computer to execute
     its next instructions in numerical sequence beginning with the
     line referred to in the command's input (instead of continuing
     in its current numerical sequence).

6.LOCAL (one input)
     Only used within a procedure definition. The command causes 
     its input to become a localname as in the case with procedure
     inputs. (See Section 1.6 for detailed discussion.)

7.TEST (one input)
     The input must either beone of the two words "TRUE" or
     "FALSE" or an operation which outputsone of them. The result
     of the command is to set the "truth flag" either to true or
     false. The "truth flag" is automatically local to every proce-
     dure and is initially set to true.

8.IF TRUE (one input)
     Here the input may bea command or an operation. The status
     of the truth flag is tested and the input isexecuted if the flag
     is true.

9.IF FALSE (one input)
     Like IF TRUE, except that its input is executedif the flag
     is false.

10.GOODBYE (no inputs)
     Disconnects the user from the computer and turns off his
     console.

11.PRINT (one input)
     Causes the input to be typed on the console followedby a
     carriage return - line feed.

12.TYPE (one input)
     Like PRINT but without the final carriage return - line feed.
     TYPE facilitates the typing of a series of printouts on a single
     line.

13.MAKE (two inputs)
     The first input becomes the name of the second input, as
     discussed in detail in Section 1.6.

14.DO (one input)
     The input must be a LOGO instruction. The DO command causes
     this instruction to be executed.

15.RESET CLOCK (no inputs)
     Causes a special LOGO one-second counter, CLOCK, to be reset
     to zero. CLOCK is started off at zero when a user starts up LOGO.
     It is incremented automatically.

16.WAIT (one input)
     The input must be a number.The command causes the computer
     to pause that number of seconds.Pauses of more than 24 hours
     are illegal.




2.The LOGO System
-----------------

We distinguish the LOGO system from the LOGO languageas follows. The language consists of all those things (the operations, commands, names, etc., and the rules governing their relationsand usage) necessary to express an executable LOGO program. The system consists of those additional things - features and facilities - that aid a user in his programming work at the computer terminal. These have to do mainly with program manipulation and debugging capabilities such as listing, editing,storing, and retrieving.


2.1 Editing


After a procedure has been defined and run, it often becomes necessary to make some changes in its definition. This can be done using the command EDIT. To illustrate the use of EDIT,consider the following definition of the procedure REVERSE.

          ?TO REVERSE :Y
	  >10 TEST EMPTYP OF :X
	  >20 OUTPUT WORD OF LAST OF :X AND REVERS OF BUTLAST OF :X
	  >END
	  REVERSE DEFINED
	  ?

There are three errors in this definition.fFirst, a line is needed between 10 and 20 telling what to do if :X is the emptyword. That can be fixed by the following instructions.

          ?EDIT REVERSE
	  >15 IF TRUE OUTPUT :EMPTY


The first instruction, using the EDIT command, tells LOGO that the definition of REVERSE will be modified. The second instruction defines a new line in the procedure. This line is inserted as number 15 between lines 10 and 20. (Here you see our reason for generally numbering lines 10, 20, 30,...instead of 1, 2,3,... - to leave room for subsequent insertions.)

The second error is a bug in the title line. There the input is referred to as :Y but elsewhere in the procedure as :X. The title line is changed as follows.
          
	  >TITLE TO REVERSE :X
	  >

Last, in line 20 REVERSE is spelled without the final E. We can correct this by simply retyping the line.

          >20 OUTPUT WORD OF LAST OF :X AND REVERSE OF BUTLAST OF :X

Now we have finished fixing the procedure, so we type END.

          >END
	  REVERSE DEFINED

After LOGO acknowledges the redefinition of REVERSE, we can tryout the modified procedure.
          ?PRINT REVERSE OF "PITH"
	  HTIP
	  ?

There is a useful feature which could have reduced our work in correcting line 20. The command EDIT LINE (one input) tells LOGO that the user wants to make changes in the line specified. In order to avoid retyping of correct words in the old line being corrected, the computer recognizes the key ^N (indicating the joint striking of the control key and the letter N key on the console) as representing "the next word in the old line". Each time ^N is struck, it causes the next word of the old line to be typed. Thus, in our example (the user's typing is underscored):

>EDIT LINE 20
>20 ^N OUTPUT ^NWORD ^NOF ^NLAST ^NOF ^N:X ^NAND ^NREVERS \E ^ROF BUTLAST OF :X
    --        --     --   --     --   --   --    --       -- -- 
(Since ^N and ^R don't type out anything on the console, the above line looks readable.) The ^R (standing for the rest or remainder of the old line) indicates to LOGO that it is to provide enough ^N's to finish the line. The backslash (\) before the E is used to erase the space the computer typed after REVERS. (In general, the backslash character \ erases the precedingcharacter, \\ erases the two preceding characters, and so on.) Weerases the preceding word (back to the first space) and types a \ for every character it erases. Backslash and We work during all typing, not just during editing.





2.1 Editing

2.2 Abbreviating

2.3 Listing and Erasing

2.4 Debugging

2.5 Filing


3.Summary of LOGO Operations, Commands, Special Names,
and Abbreviations


                         OPERATIONS
			 
FIRST          (1 INPUT) FIRST LETTER OF WORD OR FIRST WORD OF SENTENCE
LAST	       (1 INPUT) LAST LETTER OF WORD OR LAST WORD OF SENTENCE
BUTFIRST       (1 INPUT) ALL BUT THE FIRST
BUTLAST        (1 INPUT) ALL BUT THE LAST
WORD 	       (2 INPUTS) CONCATENATES THE TWO INPUTS INTO A WORD
SENTENCE       (2 INPUTS) CONCATENATES THE TWO INPUTS WITH A SPACE BETWEEN THEM
COUNT	       (1 INPUT) THE NUMBER OF LETTERS IN A WORD OR WORDS IN A SENTENCE
SUM	       (2 INPUTS) THE ALGEBRAIC SUM OF TWO INTEGERS
DIFFERENCE     (2 INPUTS) THE ALGEBRAIC DIFFERENCE OF TWO INTEGERS
MAXIMUM        (2 INPUTS) THE LARGER OF TWO INTEGERS
MINIMUM        (2 INPUTS) THE SMALLER OF TWO INTEGERS
EMPTYP	       (1 INPUT) TRUE OR FALSE AS INPUT IS /EMPTY/ OR NOT
ZEROP	       (1 INPUT) TRUE OR FALSE AS INPUT IS 0 OR NOT
WORDP	       (1 INPUT) TRUE OR FALSE AS INPUT IS WORD OR NOT
SENTENCEP      (1 INPUT) TRUE OR FALSE AS INPUT IS SENTENCE OR NOT
NUMBERP        (1 INPUT) TRUE OR FALSE AS INPUT IS NUMBER OR NOT
GREATERP       (2 INPUTS) TRUE OR FALSE AS FIRST INPUT IS LARGER THAN SECOND OR NOT (BOTH INPUTS MUST BE INTEGERS)
IS	       (2 INPUTS) TRUE OR FALSE AS FIRST INPUT IS THE SAME AS SECOND OR NOT
THING	       (1 INPUT) THAT THING THAT THE INPUT IS THE NAME OF
PRODUCT	       (2 INPUTS) THE PRODUCT OF TWO INTEGERS
REQUEST        (NO INPUT) LITERAL TYPEIN FROM THE TERMINAL
ASK	       (1 INPUT) LITERAL TYPEIN FROM THE TERMINAL IF COMPLETED IN INPUT NUMBER OF SECONDS. OTHERWISE /EMPTY/
RANDOM	       (NO INPUTS) A RANDOM DIGITDATE(NO INPUTS) THE CURRENT DATE
TIME	       (NO INPUTS) THE CURRENT TIME
CLOCK	       (NO INPUTS) A ONE SECOND CLOCK
BOTH	       (2 INPUTS) LOGICAL AND OF TWO PREDICATES
EITHER	       (2 INPUTS) INCLUSIVE OR OF TWO PREDICATES
ENTRIES        (1 INPUT) INPUT IS A FILE NAME. OUTPUT IS SENTENCE OF SECOND NAMES OF THE ENTRIES IN THAT FILE
DATE-SAVED     (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS TIME AND DATE ENTRY WAS SAVED
DATE-GOTTEN    (1 INPUTI LIKE DATE-SAVED
OWNER	       (1 INPUT) INPUT IS A FILE NAME. OUTPUT IS NAME OF OWNER
INITIALS       (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS INITIALS OF SAVER
SIZE   	       (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS NUMBER DIRECTLY RELATED TO SIZE OF ENTRY ON THEDRUM

	       	  	 COMMANDS
			 
TO 	       DEFINE PROCEDURE
TITLE	       TO CHANGE TITLE LINE OF A PROCEDURE WHILE IN EDIT MODE
WAIT	       TAKES ONE INPUT AND WAITS THAT MANY SECONDS
IF	       FOLLOWED BY TRUE OR FALSE
EDIT	       TO CHANGE A PROCEDUREENDTO END A PROCEDURE DEFINITION
TRACE	       CAUSES PRINTOUT WHILE A PROCEDURE RUNS
ERASE	       ERASES MANY DIFFERENT THINGS
	       1. ERASE ENTRY (ENTRY NAME)
	       2. ERASE (PROCEDURE NAME)
	       3. ERASE TRACE (PROCEDURE NAME)
	       4. ERASE ALL TRACES
	       5. ERASE ALL NAMES
	       6. ERASE ABBREVIATION EXPRESSION
	       7. ERASE ALL ABBREVIATIONS
	       8. ERASE ALL PROCEDURES
	       9. ERASE ALL
	       10. ERASE LINE (NUMBER) (ONLY IN EDIT MODE)
LIST	       LIST MANY THINGS
	       1. LIST (PROCEDURE NAME)
	       2. LIST ALL PROCEDURES
	       3. LIST CONTENTS
	       4. LIST CONTENTS (ENTRY NAME)
	       5. LIST ALL NAMES
	       6. LIST NAMES (ENTRY NAME)
	       7. LIST ALL ABBREVIATIONS
	       8. LIST ABBREVIATIONS (ENTRY NAME)
	       9. LIST ALL
	       10. LIST ALL FILES
	       11. LIST FILE (FILE NAME)
	       12. LIST ENTRY (ENTRY NAME)
	       13. LIST TITLE (ONLY IN EDIT MODE)
	       14. LIST LINE (NUMBER) (ONLY IN EDIT MODEGOODBYE HALTS LOGO
PRINT	       TYPES ITS INPUT AND THEN CARRIAGE RETURNS
TYPE	       LIKE PRINT BUT WITHOUT CARRIAGE RETURN
OUTPUT	       PROCEDURE ENDS AND HAS VALUE OF EXPRESSION FOLLOWING THE COMMAND
MAKE	       SETS UP NAMES
STOPP	       ROCEDURE ENDS AND HAS NO VALUE
DO	       EXECUTES ITS INPUT AS A LOGO COMMAND
LOCAL	       DECLARES FOLLOWING NAMES AS BELONGING TO PROCEDURE IN WHICH THE COMMAND IS
SAVE	       SETS UP AN ENTRY
GET	       READS IN AN ENTRY
GO	       GO TO LINE
RESET	       RESET CLOCK SETS CLOCK TO ZERO
ABBREVIATE     SETS UP ABBREVIATIONS
TEST	       SETS TRUTH FLAG

	       	    	 ABBREVIATIONS
			 
ABB	       ABBREVIATION
ABBS	       ABBREVIATIONS
ABT	       ABBREVIATE
BF	       BUTFIRST
BL	       BUTLAST
BP	       BEFOREP
C	       COUNT
DIFF	       DIFFERENCE
D-G	       DATE-GOTTEN
D-S	       DATE-SAVED
EDL	       EDIT LINE
EDT	       EDIT TITLE
EP	       EMPTYP
ER	       ERASE
ERL	       ERASE LINE
F	       FIRST
GB	       GOODBYE
GP	       GREATERP
GTL	       GO TO LINE
LA 	       LAST
L	       LIST
LC	       LIST CONTENTS
LE	       LIST ENTRY
LL	       LIST LINE
MAX	       MAXIMUM
MIN	       MINIMUM
NP	       NUMBERP
P 	       PRINT
PRS	       PROCEDURES
RQ	       REQUEST
OP	       OUTPUT
S 	       SENTENCE
SP	       SENTENCEP
T	       TEST
W	       WORD
WP	       WORDP
ZP	       ZEROP
IFT	       IF TRUE
IFF	       IF FALSE
GP	       GREATERP
SP	       SENTENCEP
WP	       WORDP
NP	       NUMBERP
EI	       EITHER
B 	       BOTH

END OF THE DOCUMENT


