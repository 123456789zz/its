diff --git a/src/dvtm03.c b/src/dvtm03.c
index effe3ad..c0e74b2 100644
--- a/src/dvtm03.c
+++ b/src/dvtm03.c
@@ -1322,7 +1322,12 @@ tm_ssta(register struct tmdev *tm)
     if (tm->tm_state != TM03_ST_OFF && dptm) {
 	/* Slave present, see if ready for commands */
 	if (tm->tm_state == TM03_ST_READY || tm->tm_srew)
+	  {
+	    fprintf(stderr, "[tm_ssta: ready]\r\n");
 	    sts |= TM_SDRY;	/* Slave present & ready for commands */
+	  }
+	else
+	    fprintf(stderr, "[tm_ssta: not ready]\r\n");
 
 	/* SLA is a little peculiar as it is not a static state like MOL; it
 	   is set only when the slave comes online (MOL->1) while selected by
@@ -1346,6 +1351,7 @@ tm_ssta(register struct tmdev *tm)
 # endif
 
     sts |= TM_SDRY;		/* Assume "slave" always there */
+    fprintf(stderr, "[tm_ssta: ready]\r\n");
 
     if (vmt_ismounted(&(tm->tm_vmt)))	sts |= TM_SMOL;	/* Medium online */
     if (vmt_isatbot(&(tm->tm_vmt)))	sts |= TM_SBOT;	/* Phys BOT */
@@ -1510,6 +1516,7 @@ tm_cmdxct(register struct tmdev *tm, int cmd)
     case TM_ER3:	/* Erase three inch gap */
 #if KLH10_DEV_DPTM03
 	TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+	fprintf(stderr, "[tm_cmdxct 1: not ready]\r\n");
 	tm_dpcmd(tm, DPTM_ER3, (size_t)0);	/* Send ERASE-3 command to DP */
 	return;				/* Don't signal attn til done */
 #else
@@ -1524,6 +1531,7 @@ tm_cmdxct(register struct tmdev *tm, int cmd)
 	}
 #if KLH10_DEV_DPTM03
 	TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+	fprintf(stderr, "[tm_cmdxct 2: not ready]\r\n");
 	tm_dpcmd(tm, DPTM_WTM, (size_t)0);	/* Send WTM command to DP */
 	return;				/* Don't signal attn til done */
 #else
@@ -1576,6 +1584,7 @@ tm_cmdxct(register struct tmdev *tm, int cmd)
 	    TMREG(tm, RHR_CSR) &= ~TM_1GO;	/* Turn off GO */
 	}
 	TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+	fprintf(stderr, "[tm_cmdxct 3: not ready]\r\n");
 #else
 	(void) tm_io(tm, 0);	/* Errors handled by tm_io now */
 	tm_cmddon(tm);		/* Do post-xct stuff, includes clearing GO */
@@ -1598,7 +1607,10 @@ tm_cmdxct(register struct tmdev *tm, int cmd)
 	if (!tm_io(tm, 1)) {		/* Errors handled by tm_io now */
 	    TMREG(tm, RHR_CSR) &= ~TM_1GO;	/* Turn off GO */
 	}
+#if 0
 	TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+#endif
+	fprintf(stderr, "[tm_cmdxct 4: not ready]\r\n");
 #else
 	(void) tm_io(tm, 1);	/* Errors handled by tm_io now */
 	tm_cmddon(tm);		/* Do post-xct stuff, includes clearing GO */
@@ -1616,6 +1628,7 @@ tm_cmdxct(register struct tmdev *tm, int cmd)
 	    TMREG(tm, RHR_CSR) &= ~TM_1GO;	/* Turn off GO */
 	}
 	TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+	fprintf(stderr, "[tm_cmdxct 5: not ready]\r\n");
 #else
 	(void) tm_io(tm, -1);	/* Errors handled by tm_io now */
 	tm_cmddon(tm);		/* Do post-xct stuff, includes clearing GO */
@@ -2445,6 +2458,7 @@ tm_space(register struct tmdev *tm, int revf)
     TMREG(tm, RHR_STS) &= ~(TM_SBOT|TM_STM|TM_SEOT);
 #if KLH10_DEV_DPTM03
     TMREG(tm, RHR_STS) &= ~TM_SDRY;	/* Drive busy, note GO still on! */
+    fprintf(stderr, "[tm_space: not ready]\r\n");
     TMREG(tm, RHR_STS) |= TM_SPIP;	/* Positioning in progress */
     tm_dpcmd(tm,			/* Send spacing command to DP */
 	     (cnt ? (revf ? DPTM_SPR : DPTM_SPF)
