
A Description of the CLOGO Language and System (ver. 0.3)

0. Abstract

This document is based on Bolt Beranek and Newman, Inc., Report no.1889 "Programming-Languages as a Conceptual Framework for Teaching Mathematics" (Feurzeig, Papert at al., 1969). The description is relevant for CLOGO version 44 available on PDP-10/its. https://github.com/PDP-10/its.

1.The LOGO Language

1.1 Things, Operations, Commands, and Names

There are two kinds of LOGO things -- WORDS and SENTENCES.

WORDS
-----

Examples of LOGO WORDS:
"SUN"              (an English word)
"39"               (a numerical word)
"PFFS!T!220W*?"    (a nonsence word)
""                 (a special word called the EMPTY word)

SENTENCES
---------

A LOGO SENTENCE is a series of LOGO words, separated by spaces.(LOGO words do not contain spaces.)
Examples:
"GOOD MORNING"
"X + Y = 24.5"
"FLOOCH HUM BUZZ CHORB"

OPERATIONS
----------

LOGO has several elementary (i.e., built-in) OPERATIONS for manipulating LOGO things.A LOGO operation takes a fixed number of things (possibly none) as INPUTS and produces a new thing as an OUTPUT. Examples of" some built-in operations_FIRST, LAST, BUTFIRST, BUTLAST, WORD and SENTENCE-follow.


FIRST
-----

The operation FIRST takes one input, either word or sentence.Its output is the first letter (if the input is word), or the first word (if the input is a sentence).
Thus,
FIRST OF "CAT" is "C"
and
FIRST OF "DO RE MI" is "DO".

LAST, BUTFIRST, and BUTLAST
---------------------------

These operations are similar to FIRST, as the following examples show.

Name of operation              Input            Output
-----------------              -----            ------
LAST                           "CAT"            "T"
BUTFIRST                       "CAT"            "AT"
BUTLAST                        "CAT"            "CA"
LAST                           "DO RE MI"       "MI"
BUTFIRST                       "DO RE MI"       "RE MI"
BUTLAST                        "DO RE MI"       "DO RE"


WORD and SENTENCE

These operations take two inputs.Their output is the concatenation of their inputs.The inputs of WORD must be LOGO words, not sentences.The output of WORD is a LOGO word.Thus, WORD OF "DO" AND "RE" is "DORE".The inputs of SENTENCE can be LOGO words or LOGO sentences.The
output is a LOGO sentence.Thus,


Name of Operation              Inputs           Output
-----------------              ------           ------
WORD                           "TIC" "TAC"      "TICTAC"
SENTENCE                       "TIC" "TAC"      "TIC TAC"
SENTENCE                       "PUT ME" "HERE"  "PUT ME HERE"
WORD                           "PUT ME" "HERE"  (Error Message)


The entire set of elementary, i.e., built-in, operations is
described in Section 1.7.

CHAINING

Operations can be chained together to form composite operations. Examples:
Chained Operation                              Output
-----------------                              ------
FIRST OF BUTFIRST OF "CAT"                      "A"
LAST OF FIRST OF "DO RE MI"                     "0"
WORD OF BUTLAST OF "CAT" AND LAST OF "X9"       "CA9"
SENTENCE OF WORD OF "A" AND "B" AND "C"         "AB C"
WORD OF "Z" AND SUM OF "1" AND "2"              "Z3"

COMMANDS
--------

LOGO has several built-in COMMANDS. Commands have inputs but, unlike operations, do not make a new LOGO thing, i.e.,they have no output.They are used for their external effects or for their side effects.

PRINT is a built-in LOGO command which has one input.Though it has no output, it has the tangible effect of causing its input to be printed out by the terminal. Thus,

Input                           Printout
-----                           --------
PRINT"CAT"			CAT
PRINT LAST OF "BOX"		X

Other built-in LOGO commands include MAKE which is used to give names to LOGO things, and TO which is used to define new LOGO operations and commands.These are describedinlater paragraphs of this section.

LITERALS
--------

In the examples above, some words and sentences are enclosed in quotation marks.This means that we reciting them literally, to refer to themselves rather than to other LOGO things.But we also can use LOGO things as names for other LOGO things.

NAMES
-----

LOGO things can have NAMES. Any LOGO thing (except the empty word) can be used as a name for any other LOGO thing.Assume that we have assigned "JANE" as the name of the thing"GIRL". We now can use"JANE" in two ways -either as thing (itself) or as a name(for the thing"GIRL").
To indicate to LOGO that we want to use something as name(in order to refer to the thing that it names), we have LOGO operation -THING, whose input is a LOGO thingandwhose output is the LOGO thing named by the input.Thus,
with the example above

Command				Printout
-------				--------
PRINT "JANE"			JANE
PRINT THING OF "JANE"		GIRL


A shorthand way of writing THING OF "ANYTHING" is :ANYTHING. Thus, the effect of the command PRINT :JANE is to cause the terminal to print GIRL.

NAMING
------

The LOGO command MAKE is used to construct a LOGO THING and give it a NAME. The following example shows how a student could use it to assign "JANE" as the name of "GIRL".

MAKE
----
   NAME: "JANE"
         ------
   THING: "GIRL"
          -----

The student's typing is underscored to distinguish it from LOGO's responses.

More typically, one names a more complex construction, as follows:

MAKE
----
   NAME: "JIM"
   	 -----
   THING: LAST OF BUTLAST OF :JANE
   	  ------------------------
	  
In this instance, with :JANE assigned as above to "GIRL", :JIM would name the THING "R" (since BUTLAST of :JANE is "GIR" and LAST of "GIR" is "R").


Constructing a New Operation

Suppose we want to define an operation which has one input and whose output is the second letter of its input (if the input is word) or the second word (if the input is sentence). We will call this new operation SECOND. (We can choose any word not already being used by LOGO as procedure name.) The procedure for performing SECOND is described to LOGO as follows.

	TO SECOND :ANYTHING
	1 OUTPUT FIRST OF BUTFIRST OF :ANYTHING
	END

TO is a command that signals the start of a procedure definition. The name of the procedure we are defining is SECOND. Its input is :ANYTHING, which names the LOGO thing we will operate upon. It has a single instruction line (in general there are several), labeled 1. The instruction is: OUTPUT the thing expressed by the chained operation FIRST OF BUTFIRST OF the word (or sentence) named by :ANYTHING. END demarcates the end of the procedure definition.

SECOND is now the procedure name for a procedure which defines a new operation. To perform this new, user-defined (as distinct from elementary or built-in) operation, we can give LOGO the command
       PRINT SECOND OF "MAN".
This tells LOGO to perform the operation SECOND on the input"MAN", i.e., that :ANYTHING is now"MAN". LOGO will perform the instructions in the procedure. It will thus output "A" to the PRINT command which will cause the terminal to print A.


1.2 Instructions


The basic unit of a LOGO INSTRUCTION is a LOGO EXPRESSION. An expression has two parts: (1) a procedure name or the name of an elementary (built-in) command or operation, followed by (2) a list of the associated inputs. Some examples of expressions are:

    (a)WORD OF "CAT" AND "DOG"
    WORD is a built-in LOGO operation that requires two inputs,
    in this case "CAT" and "DOG". The output of this expression
    is the word "CATDOG".
    
    (b)SECOND OF "APPLE PIE SOUFFLE"
    SECOND is a procedure defined by the user which requires one
    input, in this case, "APPLE PIE SOUFFLE". Assuming that the
    procedure is defined as in the previous section, the output
    of the expression would be "PIE".
    
    (c)TIMETIME is a built-in operation that requires no inputs.The
    output of this expression is the current time, for example,
    "10:34 AM".
    
The inputs in expressions may be LOGO NAMES as well as LITERALS.

    (d)FIRST OF :CHILDREN
    FIRST is a built-in operation that requires one input.The
    input here is not "CHILDREN" but rather the thing that
    "CHILDREN" names.Thus, if "CHILDREN" is the name for the
    LOGO sentence "BOYS AND GIRLS", the output of the expression
    is "BOYS".


The inputs in expressions may themselves be expressions.

    (e)FIRST OF BUTFIRST OF "ABCD"
    Here the input of the operation FIRST is the output of the
    expression BUTFIRST OF "ABCD", that is "BCD".So the output
    of the whole expression is the same as the output of FIRST
    OF "BCD", that is "B".
    
Commands are expressions.For example,

    (f)PRINT OF "ABC"This expression has no output but it causes ABC to be
    printed by the terminal.
    
    (g)PRINT OF FIRST OF "ABC"
    If this expression, PRINT has, as its input, the output of
    FIRST OF "ABC", that is "A".The effect is to cause A to
    be printed by the terminal.
    
On the other hand, the form

   (h)FIRST OF PRINT OF "ABC"
   is not a legal expression because FIRST requires an input
   but the expression PRINT OF "ABC" has no output.
   
In writing expressions, the words OF and AND are optional.The expressions PRINT WORD "CAT" "DOG", PRINT OF WORD OF "CAT" AND"DOG", and PRINT WORD OF "CAT" AND "DOG" all have the same
meaning.



1.3 Procedures


Several LOGO instructions can be put together to form a PROCEDURE. This is accomplished using the instruction TO.(The user's typing is underscored to distinguish it from the computer's.)

	?TO GREET :NAME
	>10 PRINT SENTENCE OF "HELLO " AND :NAME
	>20 PRINT "I HOPE YOU'RE WELL."
	>END
	GREET DEFINED
	
	GREET "DICK"
	HELLO, DICK
	I HOPE YOU'RE WELL.
	
The instruction in first line of the example, TO GREET :NAME does several things.The word TO tells the computer that we are about to define a procedure.The next word GREET is the name of the procedure. Following this is the list of input names for the procedure, in this case only one. (If we had wanted a two-input procedure, like WORD, the first line might have been TO GREET :WHO AND :WHERE. Any number of inputs is permitted including none.) The names appearing in the input list are used in subsequent instructions to refer to the associated inputs.

After the TO instruction (also called the title line of the procedure), the computer types > at the beginning of each line to indicate that it is ready for the type-in of the next line of the procedure being defined. At this point any line typed in preceded by a number (between 1 and 999999 inclusive), as lines 10 and 20 in GREET, will be made part of the procedure definition. These instructions will subsequently be performed in the numerical sequence thus indicated. The instructions are not performed immediately as they are written  - they are merely stored as part of the definition. They can be performed later when the procedure definition has been completed.

Finally, the command END (which has no inputs) completes the definition of the procedure. The computer types GREET DEFINED. Now the computer begins lines with an question mark "?" indicating that it is ready to perform an instruction (possibly a procedure).
GREET may now be used as a LOGO command.The expression GREET "DICK" (or GREET OF "DICK") causes the computer to pair the input, "DICK" with the name in the title line of GREET, :NAME,and then to carry out the instructions in the body of the procedure GREET in the numerical order of their line numbers.

There are two ways to change the numerical order of execution of the instructions in a procedure. The first is by the command
      GO TO LINE expression
                 ----------
where the value of expression must be a line number. (Although the name of this command is sentence, GO TO LINE, it is a single entity of the same kind as commands whose names are single words.) The effect of this command is shown in the following example.

      ?TO SHOWGOTOLINE :X
      >10 GO TO LINE :X
      >20 PRINT "1"
      >30 PRINT "2"
      >40 PRINT "3"
      >50 PRINT "4"
      >END
      SHOWGOTOLINE DEFINED

      ?SHOWGOTOLINE "50"
      4
      ?SHOWGOTOLINE "30"
      2
      3
      4

      ?SHOWGOTOLINE "25"
      THERE IS NO LINE 25                   (LOGO types out these
      I WAS AT LINE 10 IN SHOWGOTOLINE      diagnostic comments.)

      ?SHOWGOTOLINE "10"
           (interrupt key pressed here after some time has gone
	   by with no printout)
      I WAS AT LINE 10 IN SHOWGOTOLINE
      
In the above example SHOWGOTOLINE "l0" caused the computer to do line 10 over and over again until it was interrupted from the terminal. A more standard example of the use of GO TO LINE is as follows.

      ?TO TWOTIMES
      >10 MAKE
           NAME:"X"
	   THING:"1"
      >20 PRINT :X
      >30 MAKE
           NAME:"X"
	   THING:SUM OF :X AND :X
      >40 GO TO LINE 20
      >END
      TWOTIMES DEFINED

      TWO TIMES
      1
      2
      4
      8
      16
      32
      64
      (interrupted from terminal)
      I WAS AT LINE 20 IN TWOTIMES
      
The other way of altering the numerical order of execution of the instructions in a procedure is with the trio of commands TEST,IF TRUE, and IF FALSE.TEST takes one input, which must be an operation whose output must be either "TRUE" or "FALSE". (TEST can also take as input the literal words "TRUE" and "FALSE".) The effect of performing the command TEST expression is to mark a "truth flag" either true or false, depending on whether the output of expression is "TRUE" or "FALSE", respectively.
      
IF TRUE and IF FALSE are somewhat anomalous commands in that their input can be any instruction, even a command. That instruction is executed if the truth flag matches the second word of the IF--- command.

      ?TEST "TRUE"
      > IF TRUE PRINT "OF COURSE"
      OF COURSE
      ?IF FALSE PRINT "STRANGE"
      (No printout occurs since the truth flag is
      marked TRUE)
      
      ?TO SHOWTEST :X
      >10 TEST :X
      >20 IF TRUE PRINT "AXLE"
      >30 IF FALSE PRINT "CAKE"
      >40 IF TRUE PRINT "SUBWAY"
      >END
      SHOWTEST DEFINED
      ?SHOWTEST LAST OF "BLUE TRUE"
      AXLE
      SUBWAY
      ?SHOWTEST FIRST OF "FALSE LOVE"
      CAKE
      
The IF commands can be used with GO TO LINE instructions to provide conditional branching within a procedure.More broadly,they can be used to alter the sequence of execution of procedures within a program comprising many procedures (as in 30 IF TRUETARUM40 IF FALSE TARAY where the condition of the truth flag determines whether the computer does the procedure TARUM or the procedure TARAY).

TEST is made more useful by a collection of built-in operations which output either "TRUE" or "FALSE". Operations which can have only these two values are called predicates. Section 1.7 includes a list of the built-in predicates.


1.4 Defined Operations


It is possible to define new LOGO operations (i.e., procedures which have an output) by means of the command OUTPUT.

      ?TO DOUBLE :X
      >10 OUTPUT WORD OF :X AND :X
      >END
      DOUBLE DEFINED
      ?PRINT DOUBLE OF "CAT"
      CATCAT
      ?PRINT DOUBLE OF DOUBLE OF "GO"
      GOGOGOGO
      
An apparently equivalent procedure that doesn't have an output is

      ?TO DUB :X
      >10 PRINT WORD OF :X AND :X
      >END
      DUB DEFINED
      ?DUB "CAT"
      CATCAT
      
Notice that it wasn't necessary to say PRINT DUB OF "CAT" since DUB contains a PRINT command.(The appearance and disappearance of the OF is purely for euphony.The computer ignores it.) Whatfif an external PRINT'is used?

      ?PRINT DUB OF "CAT"
      CATCAT
      DUB CAN'T BE USED AS AN INPUT.IT DOESN'T HAVE AN OUTPUT.

LOGO complains.The problem is that the external PRINT didn't get any input because DUB didn't output anything -- DUB is command, not an operation.The word "CATCAT" got printed anyway because that happens before the computer gets to the end of DUB and discovers that there is no output to transmit to the external PRINT command.

The same thing happens, giving an obviously wrong answer, whe none writes
      ?DUB DUB "GO"GOGO
      GOGO
      
      DUB CAN'T BE USED AS AN INPUT.IT DOESN'T HAVE AN OUTPUT.
      
Once procedures like DOUBLE or DUB are defined, they are virtually indistinguishable in their use from the built-in operations and commands.Thus, in the same way as with the built-in ones, these too can be used to define other procedures.
      ?TO TRIPLE :X
      >10 OUTPUT WORD OF :X AND DOUBLE OF :X
      >END
      TRIPLE DEFINED
      ?PRINT TRIPLE OF "AB
      "ABABAB
      ?PRINT TRIPLE OF DOUBLE OF "R"
      RRPRRRR


1.5 Recursion

pIn fact, since a defined procedure can be used just like a built-in procedure, it can even be used in its own definition. Sometimes this gets nowhere -

      ?TO TYPEALOT
      >10 TYPEALOT
      >END
      TYPEALOT DEFINED
      >TYPEALOT
         (after a long wait the interrupt key is hit)
      I WAS AT LINE 10 IN TYPEALOT
      
It was silly to expect the computer to have been able to performthis procedure (to type a lot?) with the instructions we gave. If it didn't know what TYPEALOT meant before we defined it, it certainly wouldn't now. But it clearly was doing something when we said TYPEALOT since the terminal didn't type an ? or an error message.

When the computer receives the instruction TYPEALOT, it sees that the instruction names a defined procedure. In order to perform it, it has to look up the instructions contained in the procedure definition. The title line shows that no inputs are needed.Then the next line tells the computerto perform theprocedure TYPEALOT. To do this, the computer must look up the procedure TYPEALOT and then perform the instructions contained there.When it does this, it once more finds that it must lookup the procedure TYPEALOT, all over again. And again and again. And so this goes on forever. (Actually, the LOGO system will assume that there is an error after it has looked up this procefdure about 500 times, and will then cause the computer to stop.)

Of course, it would have been easy to design LOGO so that it would remember what procedure it was doing and not allow this situation to occur. It turns out, though, that we would have deprived ourselves of a very valuable mathematical tool had we done this.

The simplest use of the above effect (called recursion because of the recurrence of the same definition) is to note that if there had been a line preceding line 10 in the procedure TYPEALOT, this line would be done over and over again, every time the procedure is looked up. Let us add a new line, say line 5.
      ?TO TYPEALOT>
      5 PRINT "A LITTLE"
      > 10 TYPEALOT
      >END
      TYPEALOT DEFINED
      ?
      
      ?TYPEALOT
      A LITTLE
      A LITTLE
      A LITTLE
         .
	 .
	 .
	 
	     (the interrupt key is hit to stop it)
      I WAS AT LINE 5 IN TYPEALOT.


The following recursive procedure takes an input and has a stopping rule.

      ?TO TRIANGLE :ANYWORD
      > 10 TEST EMPTYP OF :ANYWORD
      > 20 IF TRUE STOP
      > 30 PRINT :ANYWORD
      > 40 TRIANGLE BUTFIRST OF :ANYWORD
      >END
      TRIANGLE DEFINED
      ?
      
EMPTYP is a built-in predicate operation that outputs "TRUE" if its input is the empty word and outputs "FALSE" otherwise. STOP is a built in command to stop this procedure, i.e., to skip the rest of the instructions in the procedure and go directly to the end.

      ?TRIANGLE ""(trying TRIANGLE with the empty word as the input)
      		  (nothing printed out but the program stopped)
      ?TRIANGLE "ABCDE"
      ABCDE
      BCDE
      CDE
      DE
      E
      ?

In the second example, the definition of TRIANGLE was looked up six times.The first five times the input was not the empty word, so the STOP command was skipped. The computer then typed the input and looked up TRIANGLE again, but this time with a smaller input (the butfirst of the previous one). Finally, the input was the empty word. For that input TRIANGLE skips lines 30 and 40 (so nothing is typed and the procedure is not looked up again) and it stops.
A well known example of this type of definition in arithmetic is the one for factorial:
      n! =1 if n=1, otherwise n!=n*(n-1)!
This can be transcribed directly to LOGO.

      ?TO FACTORIAL :N
      >10 TEST IS :N "1"
      >20 IF TRUE OUTPUT "1"
      >30 IF FALSE OUTPUT PRODUCT OF :N AND FACTORIAL OF
      	     DIFFERENCE OF :N AND "1"
      >END
      FACTORIAL DEFINED
      ?
      
IS is a built-in predicate that outputs "TRUE" if its two inputs are expressions for the same thing and"FALSE" otherwise. Line 30 is rather long but not too hard to read if one uses parentheses
PRODUCT OF ( :N ) AND (FACTORIAL OF [DIFFERENCE OF :N AND "1"]).
DIFFERENCE OF :N AND "1" is just fn-1.

Finally, it is not necessary to prefix the instruction in line 30 with the command IF FALSE, since the OUTPUT command incorporates the actions of the STOP command and, if line 20 is executed, the OUTPUT command there will skip to the end of the procedure.

1.6 Local and Global Names

In LOGO everything except the empty word is the name of something. Until they are otherwise assigned, almost all LOGO things name the empty word.

      ?PRINT :SOMETHING
          (The computer prints the empty word by skipping a line.)
      ?PRINT :AN_OTHER_THING

      ?PRINT :A

      ?PRINT ""
      THE EMPTY WORD CANNOT BE A NAME.
      ?

The few exceptions, which don't initially name the empty word, are built-in LOGO names for special things such as the teletype bell, the blank character, etc. These are listed in Part 3 (Need to be checked).

Names may have their things changed in two ways.The most direct way is by means of the instruction MAKE.

      ?MAKE
         NAME: "ALPHA"
	 THING: "BETTY"
      ?PRINT :ALPHA
      BETTY

The text following the words NAME: and THING: may be anything that has an output, that is a literal (like "ALPHA"),a name(like :JKS),or an operation with its inputs.
      ?MAKE
        NAME: :ALPHA
 	THING: "SAPLE"
      ?PRINT :BETTY
      SAPLE
      ?

The name here is :ALPHA, that is the LOGO thing "BETTY".

      ?MAKE
         NAME: SENTENCE OF "DOT" AND :ALPHA
	 THING: BUTFIRST OF :BETTY
      ?PRINT "DOT BETTY"
      APLE

Here the name of SENTENCE OF "DOT" AND :ALPHA which is "DOT BETTY" and the thing it names is BUTFIRST OF :BETTY, "APLE".

The instruction LIST ALL NAMES causes all names with non-empty things to be listed.

      ?LIST ALL NAMES
      :ALPHA IS "BETTY"
      :BETTY IS "SAPLE"
      "DOT BETTY" IS "APLE"  ;;need to be checked
      ?

Just as the OF and AND in most instructions are optional, the carriage returns after the command MAKE and before the label THING are optional. The instruction in the form

      ?MAKE(carriage return)
         NAME:"BB"(carriage return)
	 THING:"CABF"(carriage return)

can also be written with the two inputs on one line. Thus:

      ?MAKE "BB" "CABF"(carriage return)

The computer doesn't type out NAME: and THING: in this form so it is a little faster to type in.

The slow form is useful in emphasizing the relation between NAME and THING during the early stages of teaching, however.

The other method of changing names is by specifying inputs inprocedures.

      ?TO SHOW :X
      >10 PRINT "NOWI AM GOING TO PRINT :X"
      >20 PRINT :X
      >END
      >SHOW "CATS"
      NOWIAM GOING TO PRINT :X
      CATS
      ?

While the procedure SHOW is running, :X stands for "CATS". When it stops, however, the old THING OF "X" is restored. Thus,

      ?PRINT :X
              (the empty word)
      ?MAKE
         NAME:"X"
	 THING:"OLD THING"
	 ?PRINT :X
	 OLD THING
	 ?SHOW "DOGS"
	 NOW I AM GOING TO PRINT :X
	 DOGS
	 ?PRINT :X
	 OLD THING
	 ?

A name which is in force only during the running time of some procedure is called local tothat procedure. A name that isn't local to any procedure is called global. In the example above, :X ("OLD THING") was global, while :X ("DOGS") was local to SHOW. While a local :X is in force (i.e.,while the procedurefor which it is local is running), all references to :X as a name refer to the local name.
      ?TO WORRY :X
      >10 PRINT :X
      >30 PRINT THING OF "X"
      >40 MAKE
            NAME:"x"
	    THING: WORD OF "CAT" AND :X
      >50 PRINT :X
      >END
      WORRY DEFINED
      ?PRINT :X
      OLD THING
      ?WORRY "PIPE"
      PIPE
      PIPE
      CATPIPE
      ?PRINT :X
      OLD THING
      ?

One reason for this somewhat complicated situation is that it permits the student to forget about the choice of names inside of procedures that he has written. For example, suppose the student had written a procedure to output the product of two numbers and it had a title line TO PRODUCT :X AND :Y. Then, sometime later he wrote another program, called TO QUADRATIC :X, for computing (X+1)X+3X, which uses the procedure PRODUCT in its definition.
      ?TO QUADRATIC :X
      >10 MAKE
            NAME: "FIRST TERM"
	    THING: PRODUCT OF (SUM OF :X AND "1") AND :X
      >20 MAKE
            NAME: "SECOND TERM"
	    THING: PRODUCT OF "3" AND :X
      >30 OUTPUT SUM OF :FIRST_TERM AND :SECOND_TERM
      >END
      QUADRATIC DEFINED
      ?PRINT QUADRATIC OF "4"
      32
      ?

Notice that :X becomes "4" on entering QUADRATIC. In line 10 however PRODUCT OF "5" AND "4" is evaluated and so PRODUCT is run.But that causes :X to become "5" while PRODUCT is running. When PRODUCT is finished, however, we comeback to QUADRATIC, now at line 20 and see another reference to :X, meaning the :X of QUADRATIC ("4"). And, indeed, this is the way things work because the :X in PRODUCT is local tothat procedure and disappears when PRODUCT is finished, leaving the :X of QUADRATICin force.

In this case the problem could have been gotten around simply byusing different input names for all procedures, a possible, if awkward, maneuver. There is an important case where that won't work, though, and that is inrecursive procedures. There, since the procedure being called is the same procedure as the one being run, the input names are, of course,identical. Here is an example of a recursive procedure that doesn't work properly because some global names are treated as though they were local.

      ?TO REVERSE :X
      > 10 TEST EMPTYP OF :X
      > 20 IF TRUE OUTPUT :EMPTY
      > 30 MAKE
             NAME: "NEW BEGINNING"
	     THING: LAST OF :X
      >40 MAKE
             NAME:"NEW END"
	     THING: REVERSE OF BUTLAST OF :X
      >50 OUTPUT WORD OF :NEW_BEGINNING AND :NEW_END
      >END
      REVERSE DEFINED
      ?PRINT REVERSE OF "CAT"
      TTT
      ?

The problem here is at line 30 and at line 40. :NEW_BEGINNING isn't an input to REVERSE, so it isn't local. Therefore, its thing will change on subsequent calls of REVERSE. The computer does not save the things of global names in each round - it only does that for local names. (The same is true for :NEW_END though in this procedure that doesn't affect the result -- nothing that might change :NEW_END, such as a call to REVERSE, happens after line 40 where :NEW_END is set.) At line 40 another REVERSE is called. In executing this REVERSE procedure, :NEW_BEGINNING will change. REVERSE procedures can, of course, be written to avoid this problem. But this REVERSE procedure can easily be repaired by making :NEW_BEGINNING local to it. There is a command, LOCAL, to do this. LOCAL takes one input, the name that is to be made local to the procedure.

      ?TO REVERSE :X
      >5 LOCAL "NEW BEGINNING"
      > 10 TEST EMPTYP OF :X
             .   (same as before)
             .
             .
    
      >END
      REVERSE DEFINED
      ?PRINT REVERSE OF "CAT"
      TAC
      ?


1.7 List of Elementary Operations


2.The LOGO System

2.1 Editing

2.2 Abbreviating

2.3 Listing and Erasing

2.4 Debugging

2.5 Filing


3.Summary of LOGO Operations, Commands, Special Names,
and Abbreviations


                         OPERATIONS
			 
FIRST          (1 INPUT) FIRST LETTER OF WORD OR FIRST WORD OF SENTENCE
LAST	       (1 INPUT) LAST LETTER OF WORD OR LAST WORD OF SENTENCE
BUTFIRST       (1 INPUT) ALL BUT THE FIRST
BUTLAST        (1 INPUT) ALL BUT THE LAST
WORD 	       (2 INPUTS) CONCATENATES THE TWO INPUTS INTO A WORD
SENTENCE       (2 INPUTS) CONCATENATES THE TWO INPUTS WITH A SPACE BETWEEN THEM
COUNT	       (1 INPUT) THE NUMBER OF LETTERS IN A WORD OR WORDS IN A SENTENCE
SUM	       (2 INPUTS) THE ALGEBRAIC SUM OF TWO INTEGERS
DIFFERENCE     (2 INPUTS) THE ALGEBRAIC DIFFERENCE OF TWO INTEGERS
MAXIMUM        (2 INPUTS) THE LARGER OF TWO INTEGERS
MINIMUM        (2 INPUTS) THE SMALLER OF TWO INTEGERS
EMPTYP	       (1 INPUT) TRUE OR FALSE AS INPUT IS /EMPTY/ OR NOT
ZEROP	       (1 INPUT) TRUE OR FALSE AS INPUT IS 0 OR NOT
WORDP	       (1 INPUT) TRUE OR FALSE AS INPUT IS WORD OR NOT
SENTENCEP      (1 INPUT) TRUE OR FALSE AS INPUT IS SENTENCE OR NOT
NUMBERP        (1 INPUT) TRUE OR FALSE AS INPUT IS NUMBER OR NOT
GREATERP       (2 INPUTS) TRUE OR FALSE AS FIRST INPUT IS LARGER THAN SECOND OR NOT (BOTH INPUTS MUST BE INTEGERS)
IS	       (2 INPUTS) TRUE OR FALSE AS FIRST INPUT IS THE SAME AS SECOND OR NOT
THING	       (1 INPUT) THAT THING THAT THE INPUT IS THE NAME OF
PRODUCT	       (2 INPUTS) THE PRODUCT OF TWO INTEGERS
REQUEST        (NO INPUT) LITERAL TYPEIN FROM THE TERMINAL
ASK	       (1 INPUT) LITERAL TYPEIN FROM THE TERMINAL IF COMPLETED IN INPUT NUMBER OF SECONDS. OTHERWISE /EMPTY/
RANDOM	       (NO INPUTS) A RANDOM DIGITDATE(NO INPUTS) THE CURRENT DATE
TIME	       (NO INPUTS) THE CURRENT TIME
CLOCK	       (NO INPUTS) A ONE SECOND CLOCK
BOTH	       (2 INPUTS) LOGICAL AND OF TWO PREDICATES
EITHER	       (2 INPUTS) INCLUSIVE OR OF TWO PREDICATES
ENTRIES        (1 INPUT) INPUT IS A FILE NAME. OUTPUT IS SENTENCE OF SECOND NAMES OF THE ENTRIES IN THAT FILE
DATE-SAVED     (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS TIME AND DATE ENTRY WAS SAVED
DATE-GOTTEN    (1 INPUTI LIKE DATE-SAVED
OWNER	       (1 INPUT) INPUT IS A FILE NAME. OUTPUT IS NAME OF OWNER
INITIALS       (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS INITIALS OF SAVER
SIZE   	       (1 INPUT) INPUT IS ENTRY NAME. OUTPUT IS NUMBER DIRECTLY RELATED TO SIZE OF ENTRY ON THEDRUM

	       	  	 COMMANDS
			 
TO 	       DEFINE PROCEDURE
TITLE	       TO CHANGE TITLE LINE OF A PROCEDURE WHILE IN EDIT MODE
WAIT	       TAKES ONE INPUT AND WAITS THAT MANY SECONDS
IF	       FOLLOWED BY TRUE OR FALSE
EDIT	       TO CHANGE A PROCEDUREENDTO END A PROCEDURE DEFINITION
TRACE	       CAUSES PRINTOUT WHILE A PROCEDURE RUNS
ERASE	       ERASES MANY DIFFERENT THINGS
	       1. ERASE ENTRY (ENTRY NAME)
	       2. ERASE (PROCEDURE NAME)
	       3. ERASE TRACE (PROCEDURE NAME)
	       4. ERASE ALL TRACES
	       5. ERASE ALL NAMES
	       6. ERASE ABBREVIATION EXPRESSION
	       7. ERASE ALL ABBREVIATIONS
	       8. ERASE ALL PROCEDURES
	       9. ERASE ALL
	       10. ERASE LINE (NUMBER) (ONLY IN EDIT MODE)
LIST	       LIST MANY THINGS
	       1. LIST (PROCEDURE NAME)
	       2. LIST ALL PROCEDURES
	       3. LIST CONTENTS
	       4. LIST CONTENTS (ENTRY NAME)
	       5. LIST ALL NAMES
	       6. LIST NAMES (ENTRY NAME)
	       7. LIST ALL ABBREVIATIONS
	       8. LIST ABBREVIATIONS (ENTRY NAME)
	       9. LIST ALL
	       10. LIST ALL FILES
	       11. LIST FILE (FILE NAME)
	       12. LIST ENTRY (ENTRY NAME)
	       13. LIST TITLE (ONLY IN EDIT MODE)
	       14. LIST LINE (NUMBER) (ONLY IN EDIT MODEGOODBYE HALTS LOGO
PRINT	       TYPES ITS INPUT AND THEN CARRIAGE RETURNS
TYPE	       LIKE PRINT BUT WITHOUT CARRIAGE RETURN
OUTPUT	       PROCEDURE ENDS AND HAS VALUE OF EXPRESSION FOLLOWING THE COMMAND
MAKE	       SETS UP NAMES
STOPP	       ROCEDURE ENDS AND HAS NO VALUE
DO	       EXECUTES ITS INPUT AS A LOGO COMMAND
LOCAL	       DECLARES FOLLOWING NAMES AS BELONGING TO PROCEDURE IN WHICH THE COMMAND IS
SAVE	       SETS UP AN ENTRY
GET	       READS IN AN ENTRY
GO	       GO TO LINE
RESET	       RESET CLOCK SETS CLOCK TO ZERO
ABBREVIATE     SETS UP ABBREVIATIONS
TEST	       SETS TRUTH FLAG

	       	    	 ABBREVIATIONS
			 
ABB	       ABBREVIATION
ABBS	       ABBREVIATIONS
ABT	       ABBREVIATE
BF	       BUTFIRST
BL	       BUTLAST
BP	       BEFOREP
C	       COUNT
DIFF	       DIFFERENCE
D-G	       DATE-GOTTEN
D-S	       DATE-SAVED
EDL	       EDIT LINE
EDT	       EDIT TITLE
EP	       EMPTYP
ER	       ERASE
ERL	       ERASE LINE
F	       FIRST
GB	       GOODBYE
GP	       GREATERP
GTL	       GO TO LINE
LA 	       LAST
L	       LIST
LC	       LIST CONTENTS
LE	       LIST ENTRY
LL	       LIST LINE
MAX	       MAXIMUM
MIN	       MINIMUM
NP	       NUMBERP
P 	       PRINT
PRS	       PROCEDURES
RQ	       REQUEST
OP	       OUTPUT
S 	       SENTENCE
SP	       SENTENCEP
T	       TEST
W	       WORD
WP	       WORDP
ZP	       ZEROP
IFT	       IF TRUE
IFF	       IF FALSE
GP	       GREATERP
SP	       SENTENCEP
WP	       WORDP
NP	       NUMBERP
EI	       EITHER
B 	       BOTH

END OF THE DOCUMENT


