;;; ITS Ethernet support			-*-MIDAS-*-
;;;
;;; Copyright (C) 2018 Adam Sampson <ats@offog.org>
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program. If not, see <https://www.gnu.org/licenses/>.

;FIXME The big one - interrupts? Compare with CHAOS...
;  search "PI for Tape" in its.* - TTYCHN
;PRM p4-3 - BR6/7 "high" vs BR4/5 "low" level - so that's what's being assigned above
;  but which does the DEUNA get?
;  and "CH-11 INTERRUPT ROUTINES" in chaos.* - copy at lower PI level
;FIXME Should we use input/output queues like IMP does?
;FIXME Use the style from TCP - this is a bit of a mix at the moment
;FIXME Use Johnny Eriksson's layout workaround for UBA half-write problem

;;; Generic Ethernet support

%NE32==37777777777
%NE16==177777
%NE8==377

.BEGIN %NEH			;Fields in the Ethernet header
 PAD==2				;padding at start of buffer
 LENGTH==<PAD+6+6+2>
 WORDS==<LENGTH/4>

;FIXME Would all the MAC stuff be easier if this was 3 16-bit fields?
 DMAC0==<.BP <%NE16_4>,0>
 DMAC12==<.BP <%NE32_4>,1>
 SMAC01==<.BP <%NE32_4>,2>
 SMAC2==<.BP <%NE16_20.>,3>
 TYPE==<.BP <%NE16_4>,3>	;see %NETYP
.END %NEH

.BEGIN %NETYP			;Ethernet frame types
 IP==4000
 ARP==4006
.END %NETYP

.BEGIN %NEAH			;Fields in an Ethernet+IPv4 ARP packet
 LENGTH==<2+2+1+1+2+6+4+6+4>	;should be this long
 WORDS==<<LENGTH+3>/4>

 HRD==<.BP <%NE16_20.>,0>	;see %NEAHR
 PRO==<.BP <%NE16_4>,0>		;see %NETYP
 HLN==<.BP <%NE8_28.>,1>	;must be 6 for Ethernet MAC
 PLN==<.BP <%NE8_20.>,1>	;must be 4 for IPv4 address
 OP==<.BP <%NE16_4>,1>		;see %NEAOP
 SHA01==<.BP <%NE32_4>,2>
 SHA2==<.BP <%NE16_20.>,3>
 SPA0==<.BP <%NE16_4>,3>	;SPA split across words
 SPA1==<.BP <%NE16_20.>,4>
 THA0==<.BP <%NE16_4>,4>
 THA12==<.BP <%NE32_4>,5>
 TPA==<.BP <%NE32_4>,6>
.END %NEAH

.BEGIN %NEAHR			;ARP hardware type
 ETHER==1
.END %NEAHR

.BEGIN %NEAOP			;ARP operation
 REQ==1
 REPLY==2
.END %NEAOP

%NEATS==64.			;Max number of ARP table entries
.BEGIN %NEAT			;ARP table entry
 WORDS==3

 HA01==<.BP <%NE32>,0>		;MAC address
 HA2==<.BP <%NE16>,1>
 PA==<.BP <%NE32>,2>		;IPv4 address
.END %NEAT

EBLK

IFE IMPP, IMPUP:	0	;If no IMP, provide this variable for TELNET etc.

ETHME:	BLOCK %NEAT"WORDS	;Our MAC address, as ARP table entry
				;(device driver must initialise this)

ETHHBF:	BLOCK %NEH"WORDS	;Ethernet header unpacked
ETHABF:	BLOCK %NEAH"WORDS	;ARP packet unpacked

ETHAT:	BLOCK <%NEATS*%NEAT"WORDS> ;ARP table
ETHATS:	0			;Number of entries in ARP table

BBLK

;Process a received packet.
;R is buffer. Length in bytes is I. May clobber A-I, R.
;
ETHRX:	MOVEI TT,ETHHBF		;Unpack Ethernet header into ETHHBF
	HRL TT,R
	BLTUB TT,<ETHHBF+%NEH"WORDS-1>
	SUBI I,%NEH"LENGTH	;I now contains data length
	ADDI R,%NEH"WORDS	;R points to data

	LDB A,[%NEH"TYPE+ETHHBF]
	CAIN A,%NETYP"IP
	 JRST ETHRXI
	CAIN A,%NETYP"ARP
	 JRST ETHRXA
	BUG INFO,[Unknown Ethernet type],OCT,A
	POPJ P,

;Process an ARP packet.
;
ETHRXA:	CAIGE I,%NEAH"LENGTH	;Check size first
	 JRST ETHRAS

	MOVEI TT,ETHABF		;Unpack packet into ETHABF
	HRL TT,R
	BLTUB TT,<ETHABF+%NEAH"WORDS-1>

	LDB A,[%NEAH"HRD+ETHABF]
	LDB B,[%NEAH"HLN+ETHABF]
	HRL B,A
	CAME B,[%NEAHR"ETHER,,6]
	 JRST ETHRAH

	LDB A,[%NEAH"PRO+ETHABF]
	LDB B,[%NEAH"PLN+ETHABF]
	HRL B,A
	CAME B,[%NETYP"IP,,4]
	 JRST ETHRAP

	LDB A,[%NEAH"SPA0+ETHABF] ;Get source IP address
	LSH A,16.
	LDB B,[%NEAH"SPA1+ETHABF]
	IOR A,B

;FIXME "Search the ARP table for X" should be a routine
	MOVE E,ETHATS		;Is the IP address in the table already?
	SOS E
ETHRX1:	JUMPL E,ETHRX2		;Any more entries to check?
	LDB B,[%NEAT"PA+ETHAT(E)]
	CAMN A,B		;Match?
	 JRST ETHRX3		; Yes - update it
	SOJA E,ETHRX1		;Prev entry

ETHRX2:	MOVE E,ETHATS		;Not found in table - add new entry
	CAIL E,%NEATS		;Table full?
	 JRST [	MOVEI E,1	; Yes - flush it and start over
		MOVEM E,ETHATS	;  FIXME remove a random entry instead
		SETZM E
		JRST ETHRX3]
	AOS ETHATS

ETHRX3: DPB A,[%NEAT"PA+ETHAT(E)]	;Store IP address
	LDB C,[%NEAH"SHA01+ETHABF]	;Get sender's MAC
	LDB D,[%NEAH"SHA2+ETHABF]
	DPB C,[%NEAT"HA01+ETHAT(E)]	;Store MAC
	DPB D,[%NEAT"HA2+ETHAT(E)]

	LDB E,[%NEAH"OP+ETHABF]	;Get op
	CAIE E,%NEAOP"REQ	;Is this a request?
	 POPJ P,		;No - nothing more to do

	LDB B,[%NEAH"TPA+ETHABF]	;Get the target PA
	CAME B,[ETHUS]			;Is it our address?
	 POPJ P,		;No - nothing more to do

	MOVEI E,%NEAOP"REPLY		;Construct reply packet
	DPB E,[%NEAH"OP+ETHABF]
	DPB A,[%NEAH"TPA+ETHABF]	;Set sender PA as target PA
	DPB B,[%NEAH"SPA1+ETHABF]	;Set our PA as source PA
	LSH B,-16.
	DPB B,[%NEAH"SPA0+ETHABF]
	MOVE E,C		;Reshuffle sender's MAC from 01/2 to 0/12 form
	LSH C,-16.
	LSH E,16.
	IOR D,E
	DPB C,[%NEAH"THA0+ETHABF]	;Set as target HA
	DPB D,[%NEAH"THA12+ETHABF]
	DPB C,[%NEH"DMAC0+ETHHBF]	;Set as destination MAC in header
	DPB D,[%NEH"DMAC12+ETHHBF]
	LDB C,[%NEAT"HA01+ETHME]	;Get our HA
	LDB D,[%NEAT"HA2+ETHME]
	DPB C,[%NEAH"SHA01+ETHABF]	;Set as source HA
	DPB D,[%NEAH"SHA2+ETHABF]

	MOVEI R,ETHABF			;Send it!
	MOVEI I,%NEAH"LENGTH
	PUSHJ P,ETHTX
	 JFCL				;Doesn't matter if it fails
	POPJ P,

ETHRAS:	BUG INFO,[ARP packet too short, length ],OCT,I
	POPJ P,
ETHRAH:	BUG INFO,[ARP wrong hardware type ],OCT,B
	POPJ P,
ETHRAP:	BUG INFO,[ARP wrong protocol ],OCT,B
	POPJ P,

;Process an IPv4 packet.
;May clobber A-I, R.
;
ETHRXI:	PUSH P,Q		;IP can clobber all of these...
	PUSH P,J
	PUSH P,R
	PUSH P,W
	PUSH P,H

	MOVE A,I		;Compute number of words
	ADDI A,3
	LSH A,-2
	MOVE C,A
	PUSHJ P,IPGIPT		;Get IP buffer -> A=datagram struct
	 JRST ETHRX5		; No buffers

	MOVE B,PK.BUF(A)	;IPGIPT does return this, but in BLKI form...
	HRL B,R
	ADDI C,-1(B)
	BLTUB B,(C)		;Copy packet

	MOVE B,C		;Words in datagram
	SETZM C			;Offset to header
	SETZM J			;Host table index of address (not used)
	PUSHJ P,IPRDGM

ETHRX5:	POP P,H
	POP P,W
	POP P,R
	POP P,J
	POP P,Q
	POPJ P,

;Send an IP packet (like IPKSNC for CHAOS).
;A contains datagram struct.
;Clobbers A, B.
;
IPKSNE:
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,I
	PUSH P,R
	PUSH P,Q
	PUSH P,T

	; Search the ARP table for the destination address.
	MOVE C,PK.DST(A)

;FIXME would this loop (and at ETHRX1) be simpler with AOBJN?
	MOVE E,ETHATS
	SOS E
ETHTX1:	JUMPL E,ETHTX2		;Any more entries to check?
	LDB B,[%NEAT"PA+ETHAT(E)]
	CAMN B,C		;Match?
	 JRST ETHTX3		; Yes
	SOJA E,ETHTX1

ETHTX2:				;Not found in ARP table
	; Destination address wasn't in the ARP table.
	; Send an ARP request instead.

	DPB C,[%NEAH"TPA+ETHABF]
	MOVE C,[ETHUS]		;FIXME use ETHME
	DPB C,[%NEAH"SPA1+ETHABF]
	LSH C,-16.
	DPB C,[%NEAH"SPA0+ETHABF]

	MOVEI C,%NETYP"ARP	;Ethernet type = ARP
	DPB C,[%NEH"TYPE+ETHHBF]
	SETOM C			;Destination MAC is all 1s
	DPB C,[%NEH"DMAC0+ETHHBF]
	DPB C,[%NEH"DMAC12+ETHHBF]

;FIXME Given this is so short, we could keep a separate buffer set up for ARP
;requests rather than building it each time...
	DPB C,[%NEAH"THA0+ETHABF]
	DPB C,[%NEAH"THA12+ETHABF]

	LDB I,[%NEAT"HA01+ETHME]
	LDB R,[%NEAT"HA2+ETHME]
	DPB I,[%NEAH"SHA01+ETHABF]
	DPB R,[%NEAH"SHA2+ETHABF]

	MOVEI C,%NEAHR"ETHER
	DPB C,[%NEAH"HRD+ETHABF]
	MOVEI C,%NETYPE"IP
	DPB C,[%NEAH"PRO+ETHABF]
	MOVEI C,6
	DPB C,[%NEAH"HLN+ETHABF]
	MOVEI C,4
	DPB C,[%NEAH"PLN+ETHABF]
	MOVEI C,%NEAOP"REQ
	DPB C,[%NEAH"OP+ETHABF]

	MOVEI R,ETHABF		;Data pointer
	MOVEI I,%NEAH"LENGTH	;Length in bytes
	PUSHJ P,ETHTX		;Send it!
	 JFCL			; Can't send - oh well, we'll try again later
	JRST ETHTX5

	; As we've sent an ARP request instead of the packet we actually
	; wanted to send, don't call IPIODN.

ETHTX3:				;Found MAC in ARP table
	; Found the destination address in the ARP table. Send it!
	LDB C,[%NEAT"HA01+ETHAT(E)]
	LDB D,[%NEAT"HA2+ETHAT(E)]
	MOVE E,C
	LSH C,16.
	DPB C,[%NEH"DMAC0+ETHHBF]
	LSH E,-16.
	IOR D,E
	DPB D,[%NEH"DMAC12+ETHHBF]

	MOVEI C,%NETYP"IP
	DPB C,[%NEH"TYPE+ETHHBF]

	MOVE R,PK.BUF(A)	;Data pointer
	LDB I,[IP$TOL(R)]	;Length in bytes, from the IP header
	PUSH P,A
	PUSHJ P,ETHTX		;Send it!
	 JRST [	POP P,A		;Couldn't send - don't mark as done.
		JRST ETHTX5]

	POP P,A
	PUSHJ P,IPIODN		;Tell IP we've sent this one.

ETHTX5:	POP P,T
	POP P,Q
	POP P,R
	POP P,I
	POP P,E
	POP P,D
	POP P,C
	POPJ P,

;Send an Ethernet packet.
;The source MAC address in the Ethernet header will be filled in
;automatically (by the adapter).
;Unpacked header is in ETHHBF. R contains pointer to unpacked data.
;I contains data length in bytes.
;Clobbers A, B, C, TT, I.
;Skip-returns on success; normal return on failure.
;
;FIXME IFN UNAP,...
ETHTX:	PUSHJ P,UNAFF			;Find a free transmit buffer
	 POPJ P,			;None left. Fail.

	MOVE TT,B			;Convert header
	HRLI TT,ETHHBF
	BLTBU TT,<%NEH"WORDS-1>(B)

	ADDI B,%NEH"WORDS		;Convert data
	MOVE TT,B
	HRL TT,R
	MOVE A,I
	ADDI A,3
	LSH A,-2
	ADD A,B
	MOVE C,TT	;XXX
	BLTBU TT,(A)

	ADDI I,%NEH"LENGTH-%NEH"PAD	;Add length of header
	AOS (P)				;Success - skip return
	JRST UNATX			;Transmit it

;Check whether the interface is able to send a packet.
;Skip-return if it is.
;
ETHCTS:
	BUG INFO,[ethcts]
;FIXME check if we have an ARP entry, and if not, send a request
	AOS (P)
	POPJ P,

IFN UNAP,[
;;; DEUNA/DELNA driver

$INSRT DEUNA

%ETMTU==1492.			;MTU (could be 1500, but be conservative)
%ETMXL==(1500./4)		;Maximum packet length in 32-bit words

EBLK

;FIXME This memory stuff would be simpler given a routine
;that allocated and mapped a page, returning the PDP-10
;address and the two Unibus addresses. We could then
;allocate on the fly while setting up the rings.
;FIXME The setup stuff might also be cleaner with byte ptrs as above.
;FIXME Or should we just use IP buffers for all of this? They seem to be
;half-page-aligned...

UNPAGS:	BLOCK %UNNPG		;PDP-10 pages: 0,,addr
UNPAGU:	BLOCK %UNNPG		;Unibus pages: first-addr,,second-addr

UNTXRP:	BLOCK %UNNTB		;Transmit ring: descriptor addr,,buffer addr
UNRXRP:	BLOCK %UNNRB		;As above for receive
;(setup code assumes those two are contiguous)

UNTXRI:	0			;Transmit ring index (next free slot)
UNRXRI:	0			;Receive ring index (next used slot)

UNADNI:	CPOPJ			;Call this after a DNI interrupt
UNARCB:	0			;Have we seen an RCBI interrupt?
;FIXME A flags word would make more sense (if we ever need a second flag!)

BBLK

; Configure and start the DEUNA.
;
UNAINI:	MOVEI D,%UNNPG-1

UNAIN1:
	CONI PI,Q		;Save PI status
	ANDI Q,177
	CONO PI,UTCOFF
	PUSHJ P,IOMQ		;Allocate a page of unshuffleable low core
	 BUG HALT,[Couldn't allocate page for DEUNA]
	CONO PI,PICON(Q)	;Restore PI status

	MOVEI B,MUETH		;Tag what it's being used for
	DPB B,[MUR,,MEMBLT(A)]

	LSH A,10.		;Save the pointer
	MOVEM A,UNPAGS(D)

	MOVE B,A
	LSH B,-9.		;DEC page number
	;FIXME Could we use %UQFST? (How do we know nobody else is?)
	; Could have a word with either 0 or the MU in...
	IORI B,%UQVAL

	PUSHJ P,UBAASL		;Allocate first UBA paging slot
	IOWRI B,UBAPAG(A)
	HRLZ C,A
	PUSHJ P,UBAASL		;Allocate second slot
	AOS B
	IOWRI B,UBAPAG(A)
	HRR C,A
	LSH C,11.
	MOVEM C,UNPAGU(D)

	MOVE A,UNPAGS(D)
	;BUG INFO,[UNA block ],OCT,D,[ entry ],OCT,B,[ pdp10 ],OCT,A,[ unibus ],OCT,C

	SOJGE D,UNAIN1

	; Initialisation sequence from DELUA user guide, page 3-8 (42).
	; This needs us to wait for an interrupt in several places, so
	; UNACMD has magic interrupt-continuation behaviour.

	; Enable interrupts. (This can't be combined with a command.)
	MOVEI A,%UN0"INTE
	IOWRI A,%UNR0

	; Set the PCB address.
	HLRZ A,UNPAGU		;Low bits
	IOWRI A,%UNR2
	LSH A,-16.		;High bits
	IOWRI A,%UNR3
	MOVEI A,%UN0"DNI+%UNCMD"GETPCB	;Ack DNI as it's on after reset
	PUSHJ P,UNACMD

	; From now on, we've been called back from UNABRK, so we're operating
	; at TTYCHN level.

	;FIXME put IP address in too, use in ARP above
	;Get the MAC address for ARP to use
	MOVE A,UNPAGS
	MOVSI TT,%UNAF"RDDPA
	MOVEM TT,0(A)
	MOVEI A,%UNCMD"GETCMD
	PUSHJ P,UNACMD
	MOVEI TT,ETHHBF		;Unpack MAC address into ETHHBF
	HRL TT,UNPAGS
	BLTUB TT,ETHHBF+1
	MOVE TT,[.BP <%NE16_4.>,ETHHBF]
	LDB A,TT
	LSH A,16.
	ILDB B,TT
	IOR A,B
	DPB A,[%NEAT"HA01+ETHME]
	ILDB A,TT
	DPB A,[%NEAT"HA2+ETHME]

	;Set up transmit and receive rings
	MOVE D,UNPAGS		;Point to TDR (RDR follows)
	ADDI D,<%UNTDR/4>

	SETZM C			;Buffer index

UNAIN2: MOVE TT,C		;Work out index into UNPAGS/UNPAGU
	LSH TT,-1
	AOS TT
	HLRZ B,UNPAGU(TT)	;Get Unibus addr. Even on the left...
	TRNE C,1
	 HRRZ B,UNPAGU(TT)	;... and odd on the right
	ADDI B,%UNBOF		;Add word-aligning padding at start

	;FIXME This bit for now, until I rewrite this whole section..
	HRLM D,UNTXRP(C)	;Descriptor pointer
	MOVE A,UNPAGS(TT)
	TRNE C,1
	 ADDI A,1000
	HRRM A,UNTXRP(C)	;Data pointer
	MOVE A,UNTXRP(C)

	MOVSI A,%UNBSZ		;SLEN (only used for recv)
	HRR A,B			;SEGB low bits
	MOVEM A,0(D)

	LSH B,-16.		;SEGB high bits
	CAIL C,%UNNTB		;in the receive ring?
	 IORI B,%UNTD"OWN	; yes - give this buffer to DEUNA
	HRLZS B			;zero other flags
	MOVEM B,1(D)

	ADDI D,2		;Next descriptor
	AOS C			;Next buffer
	CAIGE C,<%UNNTB+%UNNRB>
	 JRST UNAIN2

	;Set ring descriptor format
	MOVSI A,%UNAF"WRDRF	;Set up for UDB-using command
	PUSHJ P,UNAPCB

	HLRZ B,UNPAGU		;Get Unibus address of TDR
	ADDI B,%UNTDR
	HRLZ A,B		;TDRB low bits
	IORI A,<4_8>		;TELEN
	LSH B,-16.
	IOR A,B			;TDRB high bits
	MOVEM A,0(D)		;Store word 0/1

	MOVSI A,%UNNTB		;TRLEN
	HLRZ B,UNPAGU		;Get Unibus address of RDR
	ADDI B,%UNRDR
	HRR A,B			;RDRB low bits
	MOVEM A,1(D)		;Store word 2/3

	LSH B,-16.		;RDRB high bits
	IORI B,<4_8>		;RELEN
	HRLZS B
	IORI B,%UNNRB		;RRLEN
	MOVEM B,2(D)		;Store word 4/5

	MOVEI A,%UNCMD"GETCMD
	PUSHJ P,UNACMD

	;Start the interface
	MOVEI A,%UNCMD"START
	PUSHJ P,UNACMD

	; We don't need to do anything special on interrupts any more.
	MOVEI A,CPOPJ
	MOVEM A,UNADNI
	POPJ P,

;Set up the PCB for a command that uses the UDB.
;A=Unibus word 0 (command),,LH of Unibus word 3 (0 for most commands).
;Returns: D pointing to UDB.
;
UNAPCB: HLRZ B,UNPAGU		;Get Unibus address of UDB
	ADDI B,%UNUDB
	MOVE D,UNPAGS		;Point to PCB
	MOVE C,B		;UDBB low bits
	HLL C,A			;Command
	MOVEM C,0(D)		;Store word 0/1
	HRRZS A			;(command-specific)
	LSH A,8.
	LSH B,-16.		;UDBB high bits
	IOR A,B
	HRLZS A			;Zero word 3
	MOVEM A,1(D)		;Store word 2/3
	MOVE D,UNPAGS		;Point to UDB
	ADDI D,<%UNUDB/4>
	POPJ P,

;Send a command (in A). Then set the next instruction in the caller as UNADNI,
;and return to the caller's caller -- this means that it'll appear to return
;(in interrupt context) when the command is done.
;
UNACMD:	POP P,UNADNI		;Back to the caller when DNI is set
	IORI A,%UN0"INTE	;Keep interrupts on
	IOWRI A,%UNR0		;Send command
	POPJ P,			;Return to caller's caller

;Handle a DEUNA interrupt.
;
;FIXME Should this use a low-priority interrupt for the actual copying?
;(as CHAOS does)
	EBLK
UNABRK:	0
	BBLK
	JSR UTCSAV

	IORDI H,%UNR0		;Read status

	TRNE H,%UN0"SERI+%UN0"PCEI+%UN0"FATL+%UN0"USCI
	 BUG HALT,[DEUNA error, PCSR0=],OCT,H	;FIXME do something better!

	TRNE H,%UN0"RXI
	 PUSHJ P,UNARX

	;FIXME %UN0"TXI

;FIXME simh's code to assert RCBI is commented out...
	TRNE H,%UN0"RCBI
	 SETOM UNARCB		;Just remember for when a buffer is freed

	MOVE A,H
	ANDI A,%UN0"ALLINT+%UN0"INTE
	IOWRI A,%UNR0		;Acknowledge interrupts

	TRNE H,%UN0"DNI		;DNI handler *after* acknowledgement
	 PUSHJ P,@UNADNI	;(because it will probably issue a new cmd)

	JRST DSKEX		;Return from interrupt

;Check the receive ring for new packets, and process them.
;Ideally, we want to process packets in the same order that the DEUNA is
;writing them to the ring -- but just in case we get out of sync, we check the
;whole ring each time, starting with the first empty slot (UNRXRI) we found
;last time.
;
UNARX:	MOVSI W,<-%UNNRB>	;W = -Number to check,,buffer index
	HRR W,UNRXRI
	SETOM UNRXRI		;Haven't found an empty buffer yet

UNARX1:	HRRZ A,W		;Wrap index around
	CAIL A,%UNNRB
	 HLLZS W

	HLRZ J,UNRXRP(W)	;Descriptor

	MOVE Q,1(J)		;Is there a packet in this buffer? (OWN=0)
	TLNE Q,%UNTD"OWN
	 JRST [	SKIPGE UNRXRI	;No. First empty buffer we've found?
		 HRRZM W,UNRXRI	; Yes, start here next time
		JRST UNARX2]

	TLNE Q,%UNTD"STF	;STF+ENF should always be true, but check...
	 TLNN Q,%UNTD"ENF
	  JRST UNARSF

	TLNE Q,%UNTD"ERRS+%UNTD"OFLO
	 JRST UNARER

	HRRZ R,UNRXRP(W)	;Buffer
	LDB I,[.BP 7777,1(J)]	;Get MLEN
	SUBI I,4		;Ignore CRC at end
	PUSHJ P,ETHRX

UNARX3:	
	TLO Q,%UNTD"OWN		;Set OWN=1 to mark as free
	MOVEM Q,1(J)

	SKIPE UNARCB		;Have we had an RCB interrupt?
	 JRST [	SETZM UNARCB	;Yes. Tell the DEUNA there's a free buffer now.
		MOVEI A,%UN0"INTE+%UNCMD"PDMD
		IOWRI A,%UNR0
		JRST UNARX2]

UNARX2:	AOBJN W,UNARX1		;Repeat if we haven't looked at all buffers
	SKIPGE UNRXRI		;Repeat if we haven't found a free buffer
	 JRST UNARX1		; FIXME: Or maybe HRRZM W,UNRXRI ?

	POPJ P,

;These are only here because you can't use BUG inside []...
UNARSF:	BUG INFO,[DEUNA split frame ],OCT,Q
	JRST UNARX3
UNARER:	BUG INFO,[DEUNA frame with errors ],OCT,Q
	JRST UNARX3

;Find an empty buffer in the transmit ring.
;On success, skip return with descriptor in D, buffer in B.
;On failure (the ring is full), normal return.
;Clobbers A-TT.
;
UNAFF:	MOVSI E,<-%UNNTB>	;E = -Number to check,,buffer index
	HRR E,UNTXRI

UNAFF1:	HRRZ A,E		;Wrap index around
	CAIL A,%UNNTB
	 HLLZS E

	HLRZ D,UNTXRP(E)	;Descriptor
	MOVE A,1(D)		;Is this buffer free? (OWN=0)
	TLNE A,%UNTD"OWN
	 JRST [	AOBJN E,UNAFF1	;Try the next one
		POPJ P,]	;No buffers free.

	HRRZM E,UNTXRI		;Yes. Start at this buffer + 1 next time.
	AOS UNTXRI		; (Doesn't matter if it wraps.)

	HRRZ B,UNTXRP(E)	;Buffer
	AOS (P)			;Skip return
	POPJ P,

;Transmit a packet from a descriptor obtained by UNAFF.
;Descriptor in D, data length in bytes in I.
;Clobbers A.
;
UNATX:	HRLM I,0(D)			;Set SLEN
	MOVSI A,%UNTD"OWN+%UNTD"STF+%UNTD"ENF
	IORM A,1(D)			;Set flags

	MOVEI A,%UN0"INTE+%UNCMD"PDMD	;Tell the DEUNA to check the ring
	IOWRI A,%UNR0

	POPJ P,

] ;UNAP
