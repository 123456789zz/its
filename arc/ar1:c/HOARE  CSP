review of:  Communicating Sequential Processes


	In general I have very ambivalent feelings about this paper.
On one hand it has nice examples of the use of parallelism in
an intuitive way for some programming problems.  In general the style
used corresponds with my own prejudices as to how to program using
parallel processing.  On the other hand the language being an amalgam
of many currently existing constructs has many
loose ends.   In addition there are many peculiar restrictions
in the constructs of the language which are poorly motivated.
	The guarded commands are rather complicated and ill-defined.
The author needs to provide a more rigorous and intuitive explanation
of the terms "fail", "delay", and "wait" as being distinct states
in which a guarded command can be.
	There appears to be a problem of fairness in the constructs
proposed.  In particular it appears to be impossible to test to see
if there is an item in the output buffer of a "process".
This inability shows up in example (4) on page 10 of the paper

*[(i:1..10)console(i)?c->X!(i,c);console(i)!ack()]

which inputs characters from consoles and sends back acknowledgements.
As the program stands there is nothing to prevent all of the characters
from being input from console(1).
	Implementing recursive subroutines as arrays of "processes"
seems like a total KLUDGE.
The excuse given is that this method is "necessitated by the 'static'
design of the language".  However, it is presumably going to be necessary
to dynamically allocate an new array for each "new" invocation
of a recursive procedure in order to implement mutually recursive routines.
This same problem shows up in recursive data representation.
It becomes even worse in section 5 on monitors and scheduling where the claim
is made using arrays of processes and guards of the appropriate kind can be used
to implement monitors.  I am doubtful that monitors can be implemented
quite so easily using the constructs provided.  In particular I would like
to see the implementations of the readers-writers problem for the cases
involving giving readers priority and giving writers priority.
Also I would also be interested in seeing an implementation of a disk-head scheduler.
The problem is compounded by the fact that it seems difficult to implement
fair (starvation-free) scheduling using the primitives provided.
For example the integer semaphore implementation in section 5.2 does not
guard against starvation.   The problem continues to plague the paper in
the next section where it spoils some of the beauty of the sieve of
Eratosthenes where it is not immediately evident that 100 sieve processes
are sufficient to produce all primes less than 100000 (although it is
obvious that it will produce all primes less than 10000).
The iterative array example is very pretty.
	I believe that the way in which arrays of processes
are treated is one of the worst defects of the paper and should be corrected
before the paper is published in the CACM.
Also some of the decisions about the language need to be better motivated.
For example the decision that an output command must wait until
some other process has input the value output seems arbitrary.
Perhaps a short section describing the hardware model that seems
to underly many of the decisions:  each "process" is a hardware module
connected by physical wires to the other hardware modules with which it
communicates.
	The term "process" as used in the paper differs from the meaning
which the author has previously attached to the term in his paper
on "monitors".  Some comment as to this difference in terminology should
be inserted to warn readers.
	In summary I believe that the paper will make an important contribution
to the state of the art when these defects are overcome.  The major thrust of the
paper is in the right direction.

				Sincerely,

				Carl Hewitt
